using System;
using System.Collections.Generic;
using System.Text;
using TypeCobol.Compiler.Diagnostics;
using TypeCobol.Compiler.Scanner;

namespace TypeCobol.Compiler.Directives
{
    /// <summary>
    /// p527: A compiler-directing statement is a statement that causes the compiler to take a
    /// specific action during compilation.
    /// You can use compiler-directing statements for the following purposes:
    /// - Extended source library control (BASIS, DELETE, and INSERT statements)
    /// - Source text manipulation (COPY and REPLACE statements)
    /// - Exception handling (USE statement)
    /// - Controlling compiler listings (*CONTROL, *CBL, EJECT, TITLE, SKIP1, SKIP2,
    ///   and SKIP3 statements)
    /// - Specifying compiler options (CBL and PROCESS statements)
    /// - Specifying COBOL exception handling procedures (USE statements)
    /// The SERVICE LABEL statement is used with Language Environment condition
    /// handling. It is also generated by the CICS integrated translator (and the separate
    /// CICS translator).
    /// The following compiler directing statements have no effect: ENTER, READY or
    /// RESET TRACE, and SERVICE RELOAD.
    /// </summary>
    public enum CompilerDirectiveType
    {
        // basisCompilerStatement
        BASIS,
        // cblProcessCompilerStatement
        CBL,
        PROCESS,
        // controlCblCompilerStatement
        ASTERISK_CBL,
        ASTERISK_CONTROL,
        // copyCompilerStatement
        COPY,
        // deleteCompilerStatement
        DELETE,
        // ejectCompilerStatement
        EJECT,
        // enterCompilerStatement 
        ENTER,
        // execSqlIncludeStatement
        EXEC_SQL_INCLUDE,
        // insertCompilerStatement
        INSERT,
        // readyOrResetTraceCompilerStatement
        READY_TRACE,
        RESET_TRACE,

        // NON-STANDARD EI Compiler Directive, roughly equivalent to COPY REPLACING
        REMARKS,

        // replaceCompilerStatement
        REPLACE,
        REPLACE_OFF,
        // serviceLabelCompilerStatement
        SERVICE_LABEL,
        // serviceReloadCompilerStatement
        SERVICE_RELOAD,
        // skipCompilerStatement
        SKIP1,
        SKIP2,
        SKIP3,
        // titleCompilerStatement
        TITLE
    }

    public abstract class CompilerDirective
    {
        protected CompilerDirective(CompilerDirectiveType type)
        {
            Type = type;
        }

        public CompilerDirectiveType Type { get; }

        /// <summary>
        /// List of errors found when parsing this CompilerDirective during Preprocessor step.
        /// </summary>
        public IList<Diagnostic> ParsingDiagnostics { get; private set; }

        /// <summary>
        /// Consumed tokens of the COPY. This property is set by the PreprocessorStep
        /// after creating the new CompilerDirective instance.
        /// </summary>
        public MultilineTokensGroupSelection ConsumedTokens { get; internal set; }

        public void AddParsingDiagnostic(Diagnostic diagnostic)
        {
            if (ParsingDiagnostics == null) ParsingDiagnostics = new List<Diagnostic>();
            ParsingDiagnostics.Add(diagnostic);
        }

        public override string ToString()
        {
            return Type.ToString();
        }
    }

    /// <summary>
    /// p527: BASIS statement 
    /// The BASIS statement is an extended source text library statement. It provides a
    /// complete COBOL program as the source for a compilation.
    /// A complete program can be stored as an entry in a user-defined library and can be
    /// used as the source for a compilation. Compiler input is a BASIS statement,
    /// optionally followed by any number of INSERT and DELETE statements.
    /// Usage note: If INSERT or DELETE statements are used to modify the COBOL
    /// source text provided by a BASIS statement, the sequence field of the COBOL
    /// source text must contain numeric sequence numbers in ascending order.
    /// </summary>
    public class BasisDirective : CompilerDirective
    {
        public BasisDirective() : base(CompilerDirectiveType.BASIS)
        { }

        /// <summary>
        /// Is the name by which the library entry is known to the system
        /// environment.
        /// For rules of formation and processing rules, see the description under
        /// literal-1 and text-name of the “COPY statement” on page 530.
        /// The source file remains unchanged after execution of the BASIS statement.
        /// </summary>
        public string BasisName { get; set; }

        /// <summary>
        /// Symbol token for BasisName
        /// </summary>
        public Token TextNameSymbol { get; set; }

        public override string ToString()
        {
            return Type.ToString() + " " + BasisName;
        }
    }

    /// <summary>
    /// p528: CBL (PROCESS) statement                            
    /// With the CBL (PROCESS) statement, you can specify compiler options to be used
    /// in the compilation of the program. The CBL (PROCESS) statement is placed before
    /// the IDENTIFICATION DIVISION header of an outermost program. However, you
    /// can use more than one CBL (PROCESS) statement. Multiple CBL (PROCESS)
    /// statements must follow one another with no intervening statements of any other
    /// type.
    /// </summary>
    public class CblProcessDirective : CompilerDirective
    {        
        /// <param name="type">CBL or PROCESS</param>
        public CblProcessDirective(CompilerDirectiveType type) : base(type)
        {
            OptionsList = new List<OptionText>();
        }

        /// <summary>
        /// A series of one or more compiler options, each one separated by a comma
        /// or a space.
        /// For more information about compiler options, see Compiler options in the
        /// Enterprise COBOL Programming Guide.
        /// </summary>
        public IList<OptionText> OptionsList { get; private set; }

        /// <summary>
        /// Ex : FLAG(I,I) => Word = "FLAG", Parameters = "I,I"
        /// </summary>
        public struct OptionText
        {
            public string Word;
            public string Parameters;
        }

        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            foreach(OptionText option in OptionsList)
            {
                sb.Append('|');
                sb.Append(option.Word);
                if (!String.IsNullOrEmpty(option.Parameters))
                {
                    sb.Append('=');
                    sb.Append(option.Parameters);
                }
            }
            return Type.ToString() + sb.ToString();
        }
    }

    /// <summary>
    /// p528: *CONTROL (*CBL) statement
    /// With the *CONTROL (or *CBL) statement, you can selectively display or suppress
    /// the listing of source code, object code, and storage maps throughout the source
    /// text.                            
    /// For a complete discussion of the output produced by these options, see Getting
    /// listings in the Enterprise COBOL Programming Guide.
    /// The *CONTROL and *CBL statements are synonymous. *CONTROL is accepted
    /// anywhere that *CBL is accepted.
    /// The *CONTROL and *CBL statements must be embedded in a program source. For
    /// example, in the case of batch applications, the *CONTROL and *CBL statements
    /// must be placed between the PROCESS (CBL) statement and the end of the
    /// program (or END PROGRAM marker, if specified).
    /// The source line containing the *CONTROL (*CBL) statement will not appear in the
    /// source listing.
    /// If an option is defined at installation as a fixed option, that fixed option takes
    /// precedence over all of the following parameter and statements:
    /// - PARM (if available)
    /// - CBL statement
    /// - *CONTROL (*CBL) statement
    /// Source code listing
    /// The topic lists statements that control the listing of the input source text lines.
    /// The statement can be any of the following one:
    /// *CONTROL SOURCE [*CBL SOURCE]
    /// *CONTROL NOSOURCE [*CBL NOSOURCE]
    /// If a *CONTROL NOSOURCE statement is encountered and SOURCE has been
    /// requested as a compilation option, printing of the source listing is suppressed from
    /// this point on. An informational (I-level) message is issued stating that printing of
    /// the source has been suppressed.
    /// Object code listing
    /// The topic lists statements that control the listing of generated object code in the
    /// PROCEDURE DIVISION.
    /// The statement can be any of the following one:
    /// *CONTROL LIST [*CBL LIST]
    /// *CONTROL NOLIST [*CBL NOLIST]
    /// If a *CONTROL NOLIST statement is encountered, and LIST has been requested as
    /// a compilation option, listing of generated object code is suppressed from this point
    /// on.
    /// Storage map listing
    /// The topic lists statements that control the listing of storage map entries occurring
    /// in the DATA DIVISION.
    /// The statement can be any of the following one:
    /// *CONTROL MAP [*CBL MAP]
    /// *CONTROL NOMAP [*CBL NOMAP]
    /// If a *CONTROL NOMAP statement is encountered, and MAP has been requested
    /// as a compilation option, listing of storage map entries is suppressed from this
    /// point on.
    /// For example, either of the following sets of statements produces a storage map
    /// listing in which A and B will not appear:
    /// *CONTROL NOMAP *CBL NOMAP
    /// 01 A 01 A
    /// 02 B 02 B
    /// *CONTROL MAP *CBL MAP
    /// </summary>
    public class ControlCblDirective : CompilerDirective
    {
        /// <summary>
        /// These are not reserved words, but the possible values are the following
        /// SOURCE | NOSOURCE | LIST | NOLIST | MAP | NOMAP
        /// </summary>
        public enum ControlCblOption
        {
            SOURCE, NOSOURCE,
            LIST, NOLIST,
            MAP, NOMAP
        }

        /// <param name="type">ASTERISK_CBL or ASTERISK_CONTROL</param>
        public ControlCblDirective(CompilerDirectiveType type) : base(type)
        {
            OptionsList = new List<ControlCblOption>();
        }        

        /// <summary>
        /// The requested options are handled in the following manner:
        /// 1. If an option or its negation appears more than once in a *CONTROL statement,
        /// the last occurrence of the option word is used.
        /// 2. If the corresponding option has been requested as a parameter to the compiler,
        /// then a *CONTROL statement with the negation of the option word must
        /// precede the portions of the source text for which listing output is to be
        /// inhibited. Listing output then resumes when a *CONTROL statement with the
        /// affirmative option word is encountered.
        /// 3. If the negation of the corresponding option has been requested as a parameter
        /// to the compiler, then that listing is always inhibited.
        /// 4. The *CONTROL statement is in effect only within the source program in which
        /// it is written, including any contained programs. It does not remain in effect
        /// across batch compiles of two or more COBOL source programs.
        /// </summary>
        public IList<ControlCblOption> OptionsList { get; private set; }

        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            foreach (ControlCblOption option in OptionsList)
            {
                sb.Append('|');
                sb.Append(option.ToString());
            }
            return Type.ToString() + sb.ToString();
        }
    }

    /// <summary>
    /// p530: COPY statement                              
    /// The COPY statement is a library statement that places prewritten text in a COBOL
    /// compilation unit.
    /// Prewritten source code entries can be included in a compilation unit at compile
    /// time. Thus, an installation can use standard file descriptions, record descriptions,
    /// or procedures without recoding them. These entries and procedures can then be
    /// saved in user-created libraries; they can then be included in programs and class
    /// definitions by means of the COPY statement.
    /// Compilation of the source code containing COPY statements is logically equivalent
    /// to processing all COPY statements before processing the resulting source text.
    /// The effect of processing a COPY statement is that the library text associated with
    /// text-name is copied into the compilation unit, logically replacing the entire COPY
    /// statement, beginning with the word COPY and ending with the period, inclusive.
    /// When the REPLACING phrase is not specified, the library text is copied
    /// unchanged.      
    /// A COPY statement can appear in the source text anywhere a character string or a
    /// separator can appear.
    /// COPY statements can be nested. However, nested COPY statements cannot contain
    /// the REPLACING phrase, and a COPY statement with the REPLACING phrase
    /// cannot contain nested COPY statements.
    /// A nested COPY statement cannot cause recursion. That is, a COPY member can be
    /// named only once in a set of nested COPY statements until the end-of-file for that
    /// COPY member is reached. For example, assume that the source text contains the
    /// statement: COPY X. and library text X contains the statement: COPY Y..
    /// In this case, library text Y must not have a COPY X or a COPY Y statement
    /// More details on Replacement and comparison rules p534 -> p537.
    /// </summary>
    public class CopyDirective : CompilerDirective
    {
        /// <param name="type">COPY or EXEC_SQL_INCLUDE</param>
        public CopyDirective(CompilerDirectiveType type, Token copyOrExecToken) : base(type)
        {
            COPYToken = copyOrExecToken;
            ReplaceOperations = new List<ReplaceOperation>();
        }
        
        /// <summary>
        /// Used to properly scan imported documents
        /// </summary>
        public Token COPYToken { get; internal set; }

        /// <summary>
        /// Text-name identifies the copy text. 
        /// 
        /// If specified as a UserDefinedWord :
        /// - Can be from 1-30 characters in length
        /// - Can contain the following characters: Latin uppercase letters A-Z, Latin
        ///   lowercase letters a-z, digits 0-9, and hyphen
        /// - The first or last character must not be a hyphen
        /// - Cannot contain an underscore
        /// Neither text-name nor library-name need to be unique within a program.
        /// They can be identical to other user-defined words in the program.
        /// text-name need not be qualified. If text-name is not qualified, a library-name
        /// of SYSLIB is assumed.
        /// When compiling from JCL or TSO, only the first eight characters are used
        /// as the identifying name. When compiling with the cob2 command and
        /// processing COPY text residing in the z/OS UNIX file system, all characters
        /// are significant.
        /// 
        /// If specified as a literal :
        /// When compiling from JCL or TSO:
        /// - Literals can be from 1-30 characters in length.
        /// - Literals can contain characters: A-Z, a-z, 0-9, hyphen, @, #, or $.
        /// - The first or last character must not be a hyphen.
        /// - Literals cannot contain an underscore.
        /// - Only the first eight characters are used as the identifying name.
        /// When compiling with the cob2 command and processing COPY text
        /// residing in the z/OS UNIX file system, the literal can be from 1 to 160
        /// characters in length.
        /// 
        /// The uniqueness of text-name and library-name is determined after the formation and
        /// conversion rules for a system-dependent name have been applied.
        /// For information about the mapping of characters in the text-name, library-name, and
        /// literals, see Compiler-directing statements in the Enterprise COBOL Programming
        /// Guide.
        /// </summary>
        public string TextName { get; set; }

        /// <summary>
        /// Symbol token for TextName
        /// </summary>
        public Token TextNameSymbol { get; set; }

        /// <summary>
        /// Library-name identifies where the copy text exists.
        /// (see TextName for constraints on the format)
        /// </summary>
        public string LibraryName { get; set; }

        /// <summary>
        /// Symbol token for LibraryName
        /// </summary>
        public Token LibraryNameSymbol { get; set; }

        /// <summary>
        /// The SUPPRESS phrase specifies that the library text is not to be printed on the
        /// source listing.
        /// </summary>
        public bool Suppress { get; set; }

        /// <summary>
        /// When the REPLACING phrase is specified, the library text is copied, and each
        /// properly matched occurrence of operand-1 within the library text is replaced by the
        /// associated operand-2.
        /// operand-1, operand-2
        /// Can be either pseudo-text, an identifier, a function-identifier, a literal, or a
        /// COBOL word (except the word COPY).
        /// * pseudo-text
        /// A sequence of character-strings or separators, or both, bounded by, but not
        /// including, pseudo-text delimiters (==). 
        /// pseudo-text-1 refers to pseudo-text when used for operand-1, and
        /// pseudo-text-2 refers to pseudo-text when used for operand-2.
        /// pseudo-text-1 can consist solely of the separator comma or separator
        /// semicolon. pseudo-text-2 can be null; it can consist solely of space
        /// characters, comment lines or inline comments.
        /// Pseudo-text must not contain the word COPY.
        /// Each text word in pseudo-text-2 that is to be copied into the program is
        /// placed in the same area of the resultant program as the area in which it
        /// appears in pseudo-text-2.
        /// Pseudo-text can consist of or include any words (except COPY), identifiers,
        /// or literals that can be written in the source text.
        /// * identifier
        /// Can be defined in any section of the DATA DIVISION.
        /// * literal
        /// Can be numeric, alphanumeric, DBCS, or national.
        /// * word 
        /// Can be any single COBOL word (except COPY), including DBCS
        /// user-defined words. 
        /// You can include the nonseparator COBOL characters (for example, +, *, /,
        /// $, <, >, and =) as part of a COBOL word when used as REPLACING
        /// operands. In addition, a hyphen or underscore can be at the beginning of
        /// the word or a hyphen can be at the end of the word.
        /// For purposes of matching, each identifier-1, literal-1, or word-1 is treated as
        /// pseudo-text containing only identifier-1, literal-1, or word-1, respectively.
        /// For details, see “REPLACING phrase” on page 533.       
        /// </summary>
        public IList<ReplaceOperation> ReplaceOperations { get; set; }

#if EUROINFO_RULES
        /// <summary>
        /// List of errors found when processing this CopyDirective during CodeElement step.
        /// </summary>
        public IList<Diagnostic> ProcessingDiagnostics { get; private set; }

        public void AddProcessingDiagnostic(Diagnostic diagnostic)
        {
            if (ProcessingDiagnostics == null) ProcessingDiagnostics = new List<Diagnostic>();
            ProcessingDiagnostics.Add(diagnostic);
        }

        /// <summary>
        /// If true, remove the first 01 level data item found in the COPY text 
        /// before copying it into the main program (legacy REPLACING syntax).
        /// </summary>
        public bool RemoveFirst01Level { get; set; }

        /// <summary>
        /// If true, insert Suffix before the first '-' in all user defined words found in the COPY text 
        /// before copying it into the main program (legacy REPLACING syntax).
        /// </summary>
        public bool InsertSuffixChar => Suffix != null;

        /// <summary>
        /// Suffix which should be inserted before the first '-' in all user defined words found in the COPY text 
        /// before copying it into the main program (legacy REPLACING syntax).
        /// </summary>
        public string Suffix { get; set; }
        public string PreSuffix { get; set; }

#endif

        public override string ToString() {
			var str = new StringBuilder(Type.ToString());
			if (Suppress) str.Append(".SUPPRESS");
			if (!String.IsNullOrEmpty(TextName))
				str.Append(" " + TextName);
            if(!String.IsNullOrEmpty(LibraryName))
				str.Append(".OF(" + LibraryName + ")");
			foreach (var replace in ReplaceOperations)
				str.Append(" <").Append(replace).Append('>');
            return str.ToString();
        }
    }

    /// <summary>
    /// p537: DELETE statement
    /// The DELETE statement is an extended source library statement. It removes COBOL
    /// statements from a source program that was included by a BASIS statement.
    /// sequence-number
    /// Source program statements can follow a DELETE statement. These source program
    /// statements are then inserted into the BASIS source program before the statement
    /// following the last statement deleted (that is, in the example above, before the next
    /// statement following deleted statement 000450).
    /// Usage note: If INSERT or DELETE statements are used to modify the COBOL
    /// source program provided by a BASIS statement, the sequence field of the COBOL
    /// source program must contain numeric sequence numbers in ascending order. The
    /// source file remains unchanged. Any INSERT or DELETE statements referring to
    /// these sequence numbers must occur in ascending order.
    /// </summary>
    public class DeleteDirective : CompilerDirective
    {
        /// <summary>
        /// The sequence-number-field must be one of the following options:
        /// - A single number
        /// - A series of single numbers
        /// - A range of numbers (indicated by separating the two bounding numbers
        ///   of the range by a hyphen)
        /// - A series of ranges of numbers
        /// - Any combination of one or more single numbers and one or more
        ///   ranges of numbers
        /// </summary>
        public class SequenceNumberRange
        {
            public int From { get; set; }
            public int To { get; set; }
        }

        public DeleteDirective() : base(CompilerDirectiveType.DELETE)
        {
            SequenceNumberRangesList = new List<SequenceNumberRange>();        
        }

        /// <summary>
        /// sequence-number-field
        /// Each number must be equal to a sequence-number in the BASIS source
        /// program. This sequence-number is the six-digit number the programmer
        /// assigns in columns 1 through 6 of the COBOL coding form. The numbers
        /// referenced in the sequence-number-field of INSERT or DELETE statements
        /// must always be specified in ascending numeric order.    
        /// </summary>
        public IList<SequenceNumberRange> SequenceNumberRangesList { get; set; }

        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            foreach(SequenceNumberRange range in SequenceNumberRangesList)
            {
                sb.Append(' ');
                sb.Append(range.From);
                sb.Append("->");
                sb.Append(range.To);
            }
            return Type.ToString() + sb.ToString();
        }
    }

    /// <summary>
    /// p539: EJECT statement 
    /// The EJECT statement specifies that the next source statement is to be printed at the
    /// top of the next page.
    /// The EJECT statement must be embedded in a program source. For example, in the
    /// case of batch applications, the EJECT statement must be placed between the CBL
    /// (PROCESS) statement and the end of the program (or the END PROGRAM marker,
    /// if specified).
    /// The EJECT statement has no effect on the compilation of the source unit itself.
    /// </summary>
    public class EjectDirective : CompilerDirective
    {
        public EjectDirective() : base(CompilerDirectiveType.EJECT)
        { }
    }

    /// <summary>
    /// p539: ENTER statement
    /// The ENTER statement is designed to facilitate the use of more than one source
    /// language in the same source program. However, only COBOL is allowed in the
    /// source program.
    /// The ENTER statement is syntax checked but has no effect on the execution of the
    /// program.
    /// </summary>
    public class EnterDirective : CompilerDirective
    {
        public EnterDirective() : base(CompilerDirectiveType.ENTER)
        { }

        /// <summary>
        /// A system name that has no defined meaning. It must be either a correctly
        /// formed user-defined word or the word "COBOL." At least one character
        /// must be alphabetic.
        /// </summary>
        public string LanguageName { get; set; }

        /// <summary>
        /// Must follow the rules for formation of a user-defined word. At least one
        /// character must be alphabetic.
        /// </summary>
        public string RoutineName { get; set; }

        public override string ToString()
        {           
            return Type.ToString() + " " + LanguageName + (RoutineName == null ? "" : (" " + RoutineName));
        }
    }

    /// <summary>
    /// p540: INSERT statement
    /// The INSERT statement is a library statement that adds COBOL statements to a
    /// source program that was included by a BASIS statement.
    /// The sequence-number-field must be a single number (for example, 000130). At
    /// least one new source program statement must follow the INSERT
    /// statement for insertion after the statement number specified by the
    /// sequence-number-field.
    /// New source program statements following the INSERT statement can include any
    /// COBOL syntax.
    /// Usage note: If INSERT or DELETE statements are used to modify the COBOL
    /// source program provided by a BASIS statement, the sequence field of the COBOL
    /// source program must contain numeric sequence numbers in ascending order. The
    /// source file remains unchanged. Any INSERT or DELETE statements referring to
    /// these sequence numbers must occur in ascending order.
    /// </summary>
    public class InsertDirective : CompilerDirective
    {
        public InsertDirective() : base(CompilerDirectiveType.INSERT)
        { }

        /// <summary>
        /// sequence-number-field
        /// A number that must be equal to a sequence-number in the BASIS source
        /// program. This sequence-number is a six-digit number that the programmer
        /// assigns in columns 1 through 6 of the COBOL source line.
        /// </summary>
        public int SequenceNumber { get; set; }

        public override string ToString()
        {
            return Type.ToString() + " " + SequenceNumber.ToString();
        }
    }

    /// <summary>
    /// p540: READY or RESET TRACE statement
    /// The READY or RESET TRACE statement was designed to trace the execution of
    /// procedures. The READY or RESET TRACE statement can appear only in the
    /// PROCEDURE DIVISION, but has no effect on your program.
    /// You can trace the execution of procedures by using the USE FOR DEBUGGING
    /// declarative as described in Example: USE FOR DEBUGGING in the Enterprise
    /// COBOL Programming Guide.
    /// </summary>
    public class ReadyOrResetTraceDirective : CompilerDirective
    {
        /// <param name="type">READY_TRACE or RESET_TRACE</param>
        public ReadyOrResetTraceDirective(CompilerDirectiveType type) : base(type)
        { }
    }

    /// <summary>
    /// One replacement operation can be of several types (distinguished for optimization purposes) 
    /// </summary>
    public enum ReplaceOperationType
    {
        /// <summary>
        /// one comparison token => zero or one replacement token
        /// </summary>
        SingleToken,
        /// <summary>
        /// one pure partial word => one replacement token
        /// </summary>
        PartialWord,
        /// <summary>
        /// one comparison token => more than one replacement tokens
        /// </summary>
        SingleToMultipleTokens,
        /// <summary>
        /// one first + several following comparison tokens => zero to many replacement tokens
        /// </summary>
        MultipleTokens
    }

    /// <summary>
    /// A replace operation is described by two set of tokens :
    /// - comparison tokens : pseudo-text-1 
    /// Must contain one or more text words. 
    /// Character-strings can be continued in accordance with normal source code rules. 
    /// pseudo-text-1 can consist solely of a separator comma or a separator semicolon. 
    /// - replacement tokens : pseudo-text-2 
    /// Can contain zero, one, or more text words. 
    /// Character strings can be continued in accordance with normal source code rules.
    /// </summary>
    public abstract class ReplaceOperation
    {
        /// <summary>
        /// Type of replace operation : number of comparison tokens / number of replacement tokens
        /// </summary>
        public ReplaceOperationType Type { get; protected set; }

        /// <summary>
        /// First token to compare with source text in the replace operation
        /// </summary>
        public Token ComparisonToken { get; protected set; }

		protected static string NoQuotes(Token token) {
			if (token == null) return "?";
			return token.SourceText.Trim('\"').Trim('\'');
		}

		public override string ToString() {
			return "REPLACE["+Type+"] "+NoQuotes(ComparisonToken);
		}
    }

    /// <summary>
    /// One comparison token => zero or one replacement token
    /// </summary>
    public class SingleTokenReplaceOperation : ReplaceOperation
    {
        public SingleTokenReplaceOperation(Token comparisonToken, Token replacementToken)
        {
            Type = ReplaceOperationType.SingleToken;
            ComparisonToken = comparisonToken;
            ReplacementToken = replacementToken;
        }

        /// <summary>
        /// Imported token injected in source text to replace matched token
        /// </summary>
        public Token ReplacementToken { get; private set; }

		public override string ToString() {
			return base.ToString()+" BY "+NoQuotes(ReplacementToken);
		}
    }

    /// <summary>
    /// One pure partial word => one replacement token
    /// </summary>
    public class PartialWordReplaceOperation : ReplaceOperation
    {
        public PartialWordReplaceOperation(Token comparisonToken, Token replacementToken)
        {
            Type = ReplaceOperationType.PartialWord;
            ComparisonToken = comparisonToken;
            PartialReplacementToken = replacementToken;
        }

        /// <summary>
        /// Imported token combined with partial word in source text to replace matched token
        /// </summary>
        public Token PartialReplacementToken { get; private set; }

		public override string ToString() {
			return base.ToString()+" BY "+NoQuotes(PartialReplacementToken);
		}
    }

    /// <summary>
    /// One comparison token => more than one replacement tokens
    /// </summary>
    public class SingleToMultipleTokensReplaceOperation : ReplaceOperation
    {
        public SingleToMultipleTokensReplaceOperation(Token comparisonToken, Token[] replacementTokens)
        {
            Type = ReplaceOperationType.SingleToMultipleTokens;
            ComparisonToken = comparisonToken;
            ReplacementTokens = replacementTokens;
        }

        /// <summary>
        /// Array of tokens injected in source text to replace matched token
        /// </summary>
        public Token[] ReplacementTokens { get; private set; }

		public override string ToString() {
			var str = new StringBuilder();
			if (ReplacementTokens != null) {
				foreach(var token in ReplacementTokens) str.Append(NoQuotes(token)).Append(',');
				if (ReplacementTokens.Length > 0) str.Length -= 1;
			}
			return base.ToString()+" BY "+str.ToString();
		}
    }

    /// <summary>
    /// One first + several following comparison tokens => zero to many replacement tokens
    /// </summary>
    public class MultipleTokensReplaceOperation : ReplaceOperation
    {
        public MultipleTokensReplaceOperation(Token firstComparisonToken, Token[] followingComparisonTokens, Token[] replacementTokens)
        {
            Type = ReplaceOperationType.MultipleTokens;
            ComparisonToken = firstComparisonToken;
            FollowingComparisonTokens = followingComparisonTokens;
            ReplacementTokens = replacementTokens;
        }

        /// <summary>
        /// Array of tokens injected in source text to replace matched tokens
        /// </summary>
        public Token[] FollowingComparisonTokens { get; private set; }

        /// <summary>
        /// Array of tokens injected in source text to replace matched tokens
        /// </summary>
        public Token[] ReplacementTokens { get; private set; }

		public override string ToString() {
			var str = new StringBuilder(base.ToString());
			foreach(var token in FollowingComparisonTokens) str.Append(',').Append(NoQuotes(token));
			str.Append(" BY ");
			if (ReplacementTokens != null) {
				foreach(var token in ReplacementTokens) str.Append(NoQuotes(token)).Append(',');
				if (ReplacementTokens.Length > 0) str.Length -= 1;
			}
			return str.ToString();
		}
    }


    /// <summary>
    /// Legacy syntax used instead of COPY REPLACING :
    /// *REMARKS. COPY=(YI03PCBA YI03PCBB).
    /// 01 I03PCBA. COPY YI03PCBA.
    /// 01 I03PCBB. COPY YI03PCBB.
    /// 
    /// Operations exécuted by the preprocessor :
    /// - import COPY YI03PCB (text name without one char suffix)
    /// - remove level 01 code element in the imported COPY
    /// - insert one char suffix A or B before the first '-' in each data name inside the COPY
    /// 
    /// This enables to import two times the same COPY but with different names for its fields.
    /// It is a legacy equivalent of COPY REPLACING + usage of partial names in the copy text.
    /// </summary>
    public class RemarksDirective : CompilerDirective
    {
        public RemarksDirective() : base(CompilerDirectiveType.REMARKS)
        {
            CopyTextNamesVariations = new List<TextNameVariation>();
        }

        /// <summary>
        /// List of variations for COPY text names included in the program
        /// </summary>
        public IList<TextNameVariation> CopyTextNamesVariations { get; set; }        

        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            bool isFirst = true;
            foreach (var textNameViariation in CopyTextNamesVariations)
            {
                if (isFirst)
                {
                    isFirst = false;
                }
                else
                {
                    sb.Append(" ,");
                }
                sb.Append(textNameViariation.ToString());
            }
            return Type.ToString() + " " + sb.ToString();
        }

        /// <summary>
        /// Stores a text name : if the text name is of length 8, then the last character must be interpreted like a suffix
        /// </summary>
        public class TextNameVariation
        {
            public TextNameVariation(string textNameWithSuffix)
            {
                TextNameWithSuffix = textNameWithSuffix;
            }

            /// <summary>
            /// Text name with potential appended suffix
            /// </summary>
            public string TextNameWithSuffix { get; private set; }

            /// <summary>
            /// True if a suffix was appended to text name
            /// </summary>
            public bool HasSuffix => TextNameWithSuffix.Length >= 8;

            /// <summary>
            /// Text name without suffix
            /// </summary>
            public string TextName { get { return HasSuffix ? TextNameWithSuffix.Substring(0, 7) : TextNameWithSuffix; } }

            /// <summary>
            /// Suffix appended to text name
            /// </summary>
            public string Suffix { get { return HasSuffix ? TextNameWithSuffix.Substring(7, 1).ToUpper() : string.Empty; } }

            /// <summary>
            /// Return the the three letters from index 5 to 7 of the Copy name.
            /// </summary>
            public string PreSuffix { get { return HasSuffix ? TextName.Substring(4).ToUpper() + "-" : string.Empty; } }

            public override string ToString()
            {
                if (HasSuffix)
                {
                    return TextName.Substring(0, 7) + "(" + Suffix + ")";
                }
                else
                {
                    return TextName;
                }
            }
        }
    }


    /// <summary>
    /// p541: REPLACE statement
    /// The REPLACE statement is used to replace source text.
    /// A REPLACE statement can occur anywhere in the source text that a
    /// character-string can occur.
    /// The REPLACE statement provides a means of applying a change to an entire
    /// COBOL compilation group, or part of a compilation group, without manually
    /// having to find and modify all places that need to be changed. It is an easy method
    /// of doing simple string substitutions. It is similar in action to the REPLACING
    /// phrase of the COPY statement, except that it acts on the entire source text, not just
    /// on the text in COPY libraries.
    /// Format 1 : Each matched occurrence of pseudo-text-1 in the source text is replaced by the
    /// corresponding pseudo-text-2.
    /// Format 2 (REPLACE_OFF) : 
    /// Any text replacement currently in effect is discontinued with the format-2 form of
    /// REPLACE. If format 2 is not specified, a given occurrence of the REPLACE
    /// statement is in effect from the point at which it is specified until the next
    /// occurrence of a REPLACE statement or the end of the separately compiled
    /// program.
    /// The compiler processes REPLACE statements in source text after the processing of
    /// any COPY statements. COPY must be processed first, to assemble complete source
    /// text. Then REPLACE can be used to modify that source text, performing simple
    /// string substitution. REPLACE statements cannot themselves contain COPY
    /// statements.
    /// The text produced as a result of the processing of a REPLACE statement must not
    /// contain a REPLACE statement.
    /// ... more rules on REPLACE behavior p542 -> p544
    /// </summary>
    public class ReplaceDirective : CompilerDirective
    {
        /// <param name="type">REPLACE or REPLACE_OFF</param>
        public ReplaceDirective(CompilerDirectiveType type) : base(type)
        {
            ReplaceOperations = new List<ReplaceOperation>();        
        }

        /// <summary>
        /// The comparison operation to determine text replacement starts with the leftmost source text word 
        /// following the REPLACE statement, and with the first pseudo-text-1.
        /// pseudo-text-1 is compared to an equivalent number of contiguous source text words. 
        /// pseudo-text-1 matches the source text if, and only if, the ordered sequence of text words that forms pseudo-text-1 is equal, 
        /// character for character, to the ordered sequence of source text words. 
        /// For national characters, the sequence of national characters must be equal,
        /// national character for national character, to the ordered sequence of library words.
        /// For purposes of matching, each occurrence of a separator comma, semicolon, or space, 
        /// and each sequence of one or more space separators is considered to be a single space.
        /// However, when pseudo-text-1 consists solely of a separator comma or semicolon, 
        /// the comma or semicolon participates in the match as a text word (in this case, the space following the comma or semicolon separator can be omitted).
        /// If no match occurs, the comparison is repeated with each successive occurrence of pseudo-text-1, 
        /// until either a match is found or there is no next successive occurrence of pseudo-text-1.
        /// When all occurrences of pseudo-text-1 have been compared and no match has occurred, 
        /// the next successive source text word is then considered as the leftmost source text word, 
        /// and the comparison cycle starts again with the first occurrence of pseudo-text-1.
        /// Whenever a match occurs between pseudo-text-1 and the source text, the corresponding pseudo-text-2 replaces the matched text in the source text. 
        /// The source text word immediately following the rightmost text word that participated in the match 
        /// is then considered as the leftmost source text word. 
        /// The comparison cycle starts again with the first occurrence of pseudo-text-1.
        /// The comparison operation continues until the rightmost text word in the source text 
        /// that is within the scope of the REPLACE statement has either participated in a match 
        /// or been considered as a leftmost source text word and participated in a complete comparison cycle. 
        /// REPLACE statement notes 
        /// Comment lines, inline comments, or blank lines occurring in the source text and in pseudo-text-1 are ignored for purposes of matching.
        /// The sequence of text words in the source text and in pseudo-text-1 is determined by the rules for reference format (see Chapter 6, “Reference format,” on page 51). 
        /// Comment lines, inline comments, or blank lines in pseudo-text-2 are placed into the resultant program unchanged
        /// whenever pseudo-text-2 is placed into the source text as a result of text replacement. 
        /// Comment lines, inline comments, or blank lines appearing in source text are retained unchanged with the following exception: 
        /// a comment line, an inline comment, or a blank line in source text is not retained 
        /// if that comment line, inline comment, or blank line appears within the sequence of text words that match pseudo-text-1.
        /// Lines containing *CONTROL (*CBL), EJECT, SKIP1/2/3, or TITLE statements can occur in source text. 
        /// Such lines are treated as comment lines during REPLACE statement processing.
        /// Debugging lines are permitted in pseudo-text. 
        /// Text words within a debugging line participate in the matching rules as if the letter "D" did not appear in the indicator area.
        /// When a REPLACE statement is specified on a debugging line, the statement is treated as if the letter "D" did not appear in the indicator area.
        /// After all COPY and REPLACE statements have been processed, a debugging line will be considered to have all the characteristics of a comment line 
        /// if the WITH DEBUGGING MODE clause is not specified in the SOURCE-COMPUTER paragraph.
        /// Except for COPY and REPLACE statements, the syntactic correctness of the source text cannot be determined 
        /// until after all COPY and REPLACE statements have been completely processed.
        /// Text words inserted into the source text as a result of processing a REPLACE statement are placed in the source text 
        /// according to the rules for reference format. When inserting text words of pseudo-text-2 into the source text, 
        /// additional spaces are introduced only between text words where there already exists a space (including the assumed space between source lines).
        /// If additional lines are introduced into the source text as a result of the processing of REPLACE statements, 
        /// the indicator area of the introduced lines contains the same character as the line on which the text being replaced begins, 
        /// unless that line contains a hyphen, in which case the introduced line contains a space.
        /// If any literal within pseudo-text-2 is of a length too great to be accommodated on a single line 
        /// without continuation to another line in the resultant program and the literal is not being placed on a debugging line, 
        /// additional continuation lines are introduced that contain the remainder of the literal. 
        /// If replacement requires the continued literal to be continued on a debugging line, the program is in error.
        /// Each word in pseudo-text-2 that is to be placed into the resultant program begins in the same area 
        /// of the resultant program as it appears in pseudo-text-2.
        /// </summary>
        public IList<ReplaceOperation> ReplaceOperations { get; private set; }

		public override string ToString() {
            var str = new StringBuilder();
			if (ReplaceOperations.Count > 0) str.Append(' ');
			foreach (var replace in ReplaceOperations)
				str.Append('<').Append(replace.ToString()).Append("> ");
			return Type.ToString()+str.ToString();
		}
    }

    /// <summary>
    /// p544: SERVICE LABEL statement
    /// This statement is generated by the CICS integrated language translator (and the separate CICS translator) 
    /// to indicate control flow. It is also used after calls to CEE3SRP when using Language Environment condition handling. 
    /// For more information about CEE3SRP, see the Language Environment Programming Guide.
    /// The SERVICE LABEL statement can appear only in the PROCEDURE DIVISION, but not in the declaratives section.        
    /// </summary>
    public class ServiceLabelDirective : CompilerDirective
    {
        public ServiceLabelDirective() : base(CompilerDirectiveType.SERVICE_LABEL)
        { }
    }

    /// <summary>
    /// p545: SERVICE RELOAD statement
    /// The SERVICE RELOAD statement is syntax checked, but has no effect on the execution of the program.
    /// </summary>
    public class ServiceReloadDirective : CompilerDirective
    {
        public ServiceReloadDirective() : base(CompilerDirectiveType.SERVICE_RELOAD)
        { }

        public string UserDefinedWord { get; set; }

        public override string ToString()
        {
            return Type.ToString() + " " + UserDefinedWord;
        }
    }

    /// <summary>
    /// p545: SKIP statements
    /// The SKIP1, SKIP2, and SKIP3 statements specify blank lines that the compiler should add when printing the source listing. 
    /// SKIP statements have no effect on the compilation of the source text itself.
    /// SKIP1
    /// Specifies a single blank line to be inserted in the source listing.
    /// SKIP2
    /// Specifies two blank lines to be inserted in the source listing.
    /// SKIP3
    /// Specifies three blank lines to be inserted in the source listing.
    /// SKIP1, SKIP2, or SKIP3 can be written anywhere in either Area A or Area B, and can be terminated with a separator period. 
    /// It must be the only statement on the line.
    /// The SKIP statements must be embedded in a program source. 
    /// For example, in the case of batch applications, a SKIP1, SKIP2, or SKIP3 statement must be placed between the CBL (PROCESS) statement and the end of the program or class (or the END CLASS marker or END PROGRAM marker, if specified).
    /// </summary>
    public class SkipDirective : CompilerDirective
    {
        /// <param name="type">SKIP1 or SKIP2 or SKIP3</param>
        public SkipDirective(CompilerDirectiveType type) : base(type)
        { }
    }
     
    /// <summary>
    /// p545: TITLE statement
    /// The TITLE statement specifies a title to be printed at the top of each page of the source listing produced during compilation.
    /// If no TITLE statement is found, a title containing the identification of the compiler and the current release level is generated. 
    /// The title is left-justified on the title line.
    /// In addition to the default or chosen title, the right side of the title line contains the following items: 
    /// - For programs, the name of the program from the PROGRAM-ID paragraph for the outermost program. (This space is blank on pages preceding the PROGRAM-ID paragraph for the outermost program.) 
    /// - For classes, the name of the class from the CLASS-ID paragraph. 
    /// - Current page number. 
    /// - Date and time of compilation.
    /// The TITLE statement: 
    /// - Forces a new page immediately, if the SOURCE compiler option is in effect 
    /// - Is not itself printed on the source listing 
    /// - Has no other effect on compilation 
    /// - Has no effect on program execution 
    /// - Cannot be continued on another line 
    /// - Can appear anywhere in any of the divisions
    /// A title line is produced for each page in the listing produced by the LIST option. This title line uses the last TITLE statement found in the source statements or the default.
    /// The word TITLE can begin in either Area A or Area B.
    /// The TITLE statement must be embedded in a class or program source. For example, in the case of batch applications, the TITLE statement must be placed between the CBL (PROCESS) statement and the end of the class or program (or the END CLASS marker or END PROGRAM marker, if specified).
    /// No other statement can appear on the same line as the TITLE statement.
    /// </summary>
    public class TitleDirective : CompilerDirective
    {
        public TitleDirective() : base(CompilerDirectiveType.TITLE)
        { }

        /// <summary>
        /// Must be an alphanumeric literal, DBCS literal, or national literal and can be followed by a separator period.
        /// Must not be a figurative constant.
        /// </summary>
        public string Title { get; set; }

        public override string ToString()
        {
            return Type.ToString() + " \"" + Title + "\"";
        }
    }
}
