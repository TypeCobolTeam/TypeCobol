using JetBrains.Annotations;
using TypeCobol.Compiler.Nodes;

namespace TypeCobol.Compiler.CodeElements
{
    /// <summary>
    /// The JSON PARSE statement converts JSON text to COBOL data.
    /// </summary>
    public class JsonParseStatement : StatementElement
    {
        public JsonParseStatement()
            : base(CodeElementType.JsonParseStatement, StatementType.JsonParseStatement)
        {

        }

        /// <summary>
        /// The data item that contains the JSON text. identifier-1 must reference one of
        /// the following items:
        /// - An elementary data item of category alphanumeric
        /// - An alphanumeric group item
        /// When identifier-1 references an alphanumeric group item, identifier-1 is
        /// treated as though it were an elementary data item of category
        /// alphanumeric.
        /// identifier-1 must not be defined with the JUSTIFIED clause, and cannot be a
        /// function identifier. identifier-1 can be subscripted or reference modified.
        /// identifier-1 must not overlap identifier-2.
        /// The JSON text is assumed to be encoded in UTF-8 (CCSID 1208).
        /// All the escaped character sequences defined in the JSON specification are
        /// accepted.Also accepted is the sequence “\x”, which is generated by JSON
        /// GENERATE, and which represents the EBCDIC NL(newline) control
        /// character X'15', equivalent to the Unicode NEXT LINE control character,
        /// NX'0085'.
        /// Conversion from Unicode of the JSON names and values is done according
        /// to the compiler CODEPAGE option in effect for the compilation.
        /// </summary>
        public ReceivingStorageArea Source { get; set; }

        /// <summary>
        /// The group or elementary data item to be populated from the JSON text.
        /// identifier-2 cannot be a function identifier or be reference modified, but it
        /// can be subscripted.
        /// identifier-2 must not overlap identifier-1.
        /// identifier-2 and its subordinate data items must not contain the
        /// UNBOUNDED clause.
        /// The data description entry for identifier-2 must not contain a RENAMES
        /// clause.
        /// The following data items that are specified by identifier-2 are ignored by
        /// the JSON PARSE statement:
        /// - Any subordinate unnamed elementary data items or elementary FILLER
        /// data items
        /// - Any slack bytes inserted for SYNCHRONIZED items
        /// - Any data item subordinate to identifier-2 that is defined with the
        /// REDEFINES clause or that is subordinate to such a redefining item
        /// - Any data item subordinate to identifier-2 that is defined with the
        /// RENAMES clause
        /// - Any group data item all of whose subordinate data items are ignored
        /// All data items specified by identifier-2 that are not ignored according to the
        /// previous rules must satisfy the following conditions:
        /// - Each elementary data item must have a USAGE other than DISPLAY-1,
        /// FUNCTION-POINTER, INDEX, OBJECT REFERENCE, POINTER, or
        /// PROCEDURE-POINTER.
        /// - There must be at least one such elementary data item.
        /// - Each non-FILLER data-name must have a unique identifier within
        /// identifier-2.
        /// - If (the data declaration of) identifier-2 or any subordinate data item
        /// contains the OCCURS DEPENDING ON clause, then the object (s) of the
        /// OCCURS DEPENDING ON clause(s) must not be subordinate to
        /// identifier-2. Thus, any objects of OCCURS DEPENDING ON clauses will
        /// not be updated by the JSON PARSE statement.
        /// </summary>
        public Variable Destination { get; set; }

        /// <summary>
        /// For the purpose of matching the name of a JSON name/value pair, the
        /// NAME phrase allows you to effectively change the name of a data item to
        /// the specified literal during the execution of the JSON PARSE statement.
        /// OMITTED can be specified to parse an anonymous JSON object, whose top
        /// parent name is not specified.
        /// identifier-3 must reference identifier-2 or one of its subordinate data items.It
        /// cannot be a function identifier and cannot be reference modified or
        /// subscripted.It must not specify any data item which is ignored by the
        /// JSON PARSE statement. For more information about identifier-2, see the
        /// description of identifier-2. If identifier-3 is specified more than once in the
        /// NAME phrase, the last specification is used.If OMITTED is specified,
        /// identifier-3 must refer to identifier-2.
        /// literal-1 must be an alphanumeric or national literal containing the JSON
        /// name to be associated with identifier-3.
        /// The NAME phrase in aggregate must not result in an ambiguous name
        /// specification.For example, given the following data declarations and JSON
        /// text:
        /// 01 G.
        ///     05 H.
        ///         10 A pic x(10).
        ///         10 3_ pic 9.
        ///         10 C-C pic x(10).
        /// ’{"g": {"H": {"A": "Eh?", "3_": 5, "C-C": "See"}}}’.
        /// Then, if it were allowed, specifying the NAME phrase as:
        /// NAME of A is ’C-C’
        /// would result in no data item receiving the value "Eh?", and an ambiguity
        /// about which data item should receive the value "See", effectively defining
        /// the declaration of group G as:
        /// 01 G.
        ///     05 H.
        ///         10 C-C pic x(10).
        ///         10 3_ pic 9.
        ///         10 C-C pic x(10).
        /// which would be illegal if referenced as identifier-2 in a JSON PARSE
        /// statement.Specifying the NAME phrase as:
        /// NAME of A is ’C-C’ C-C is ’A’
        /// is not ambiguous, and would simply swap the assignments to data items A
        /// and C-C.
        /// Given the following data declaration and JSON text:
        /// 01. top
        /// 02. A pic x(20).
        /// 03. B pic x(20).
        /// ’{"A":"value1","B":"value2"}’
        /// This JSON object can be parsed using OMITTED:
        /// NAME top IS OMITTED
        /// If OMITTED is not specified, the JSON object would need to contain a
        /// parent name called "top":
        /// ’{"top":{"A":"value1","B":"value2"}}’
        /// </summary>
        public JsonParseNameMapping[] NameMappings { get; set; }

        /// <summary>
        /// Allows you to identify and unconditionally exclude items that are
        /// subordinate to identifier-2 from assignment by the JSON PARSE statement.
        /// identifier-4 must reference a data item that is subordinate to identifier-2 and
        /// that is not otherwise ignored by the operation of the JSON PARSE
        /// statement.identifier-4 cannot be a function identifier and cannot be
        /// reference modified or subscripted.identifier-4 can reference an entire table.
        /// If identifier-4 specifies a group data item, that group data item and all data
        /// items that are subordinate to the group item are excluded.
        /// Duplicate specifications of identifier-4 are permitted.
        /// A data item that is specified in the SUPPRESS phrase, is suppressed even if
        /// the same data item is also specified in the NAME phrase.
        /// </summary>
        public Variable[] ExcludedDataItems { get; set; }

        /// <summary>
        /// Allows you to specify items that will be parsed as JSON BOOLEAN name/value pairs.
        /// </summary>
        public JsonParseConvertingDirective[] JsonConvertingDirectives { get; set; }

        public override bool VisitCodeElement(IASTVisitor astVisitor)
        {
            return base.VisitCodeElement(astVisitor)
                   && astVisitor.Visit(this)
                   && this.ContinueVisitToChildren(astVisitor, this.Destination, this.Source)
                   && this.ContinueVisitToChildren(astVisitor, this.NameMappings, this.ExcludedDataItems, this.JsonConvertingDirectives);
        }
    }

    /// <summary>
    /// Represents an association between a data item in source and a name to be used to represent
    /// this data item in the resulting generated JSON.
    /// </summary>
    public class JsonParseNameMapping : IVisitable
    {
        /// <summary>
        /// Data item to be renamed.
        /// </summary>
        public Variable DataItem { get; set; }

        /// <summary>
        /// Expected name in JSON.
        /// </summary>
        [CanBeNull]
        public AlphanumericValue InputName { get; set; }

        /// <summary>
        /// Is expected name omitted?
        /// To parse an anonymous JSON object, whose top parent name is not specified.
        /// </summary>
        public SyntaxProperty<bool> Omitted { get; set; }

        public bool AcceptASTVisitor(IASTVisitor astVisitor)
        {
            return this.ContinueVisitToChildren(astVisitor, this.DataItem, this.InputName, this.Omitted);
        }
    }

    /// <summary>
    /// Represents an association between a data item in source and its TRUE/FASE values when converting a JSON boolean to it.
    /// </summary>
    public class JsonParseConvertingDirective : IVisitable
    {
        /// <summary>
        /// identifier-5 must be a single-byte alphanumeric elementary data item whose data definition entry
        /// contains PICTURE X.
        /// </summary>
        public ReceivingStorageArea DataItem { get; set; }

        /// <summary>
        /// The USING phrase provides various methods of specifying the values that shall be effectively moved
        /// into identifier-5 when a JSON BOOLEAN true or false value is encountered during parsing.
        /// condition-name-1 must be a level-88 item directly subordinate to identifier-5 and must be specified
        /// with both the VALUE clause and the WHEN SET TO FALSE phrase.The first VALUE clause literal (of
        /// possibly many values and ranges) will be used to populate identifier-5 when parsing a JSON BOOLEAN
        /// true value.The FALSE value will be used to populate identifier-5 when parsing a JSON BOOLEAN false
        /// value.
        /// condition-name-2 and condition-name-3 must be level-88 items directly subordinate to identifier-5
        /// whose VALUE clauses are used to populate identifier-5 when a JSON BOOLEAN true or false value is
        /// parsed respectively.The first VALUE clause literal will be used in both cases.
        /// literal-2 and literal-3 must be single-byte alphanumeric literals.literal-2 and literal-3 are used to
        /// populate identifier-5 when a JSON BOOLEAN true or false value is parsed respectively.
        /// The CONVERTING phrase can be specified with multiple items to be parsed as JSON BOOLEAN name/
        /// value pairs by using the ALSO keyword.
        /// </summary>
        public Variable TrueValue { get; set; }

        /// <summary>
        /// The USING phrase provides various methods of specifying the values that shall be effectively moved
        /// into identifier-5 when a JSON BOOLEAN true or false value is encountered during parsing.
        /// condition-name-1 must be a level-88 item directly subordinate to identifier-5 and must be specified
        /// with both the VALUE clause and the WHEN SET TO FALSE phrase.The first VALUE clause literal (of
        /// possibly many values and ranges) will be used to populate identifier-5 when parsing a JSON BOOLEAN
        /// true value.The FALSE value will be used to populate identifier-5 when parsing a JSON BOOLEAN false
        /// value.
        /// condition-name-2 and condition-name-3 must be level-88 items directly subordinate to identifier-5
        /// whose VALUE clauses are used to populate identifier-5 when a JSON BOOLEAN true or false value is
        /// parsed respectively.The first VALUE clause literal will be used in both cases.
        /// literal-2 and literal-3 must be single-byte alphanumeric literals.literal-2 and literal-3 are used to
        /// populate identifier-5 when a JSON BOOLEAN true or false value is parsed respectively.
        /// The CONVERTING phrase can be specified with multiple items to be parsed as JSON BOOLEAN name/
        /// value pairs by using the ALSO keyword.
        /// </summary>
        public Variable FalseValue { get; set; }

        public JsonParseConvertingDirective(ReceivingStorageArea dataItem, Variable trueValue, Variable falseValue) => (DataItem, TrueValue, FalseValue) = (dataItem, trueValue, falseValue);

        public bool AcceptASTVisitor(IASTVisitor astVisitor)
        {
            return this.ContinueVisitToChildren(astVisitor, this.DataItem, this.TrueValue, this.FalseValue);
        }
    }
}
