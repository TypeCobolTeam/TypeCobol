using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Text;
using TypeCobol.Codegen.Actions;
using TypeCobol.Codegen.Nodes;
using TypeCobol.Compiler.CodeElements;
using TypeCobol.Compiler.Nodes;
using TypeCobol.Compiler.Scanner;
using TypeCobol.Compiler.Source;
using TypeCobol.Compiler.Text;
using TypeCobol.Tools;


namespace TypeCobol.Codegen.Generators
{
    /// <summary>
    /// This class create a mapping between Nodes and their target positions in the source code
    /// for code generation. It built a linear data structure that map each line from the source
    /// document to its corresponding nodes. The Linear structure is built in O(n) where n
    /// is the number of Nodes in the Abstract Tree Nodes.
    /// Each Node is then given an Index in to an Array Of Nodes which is constructed during a
    /// traverse of the Abstract Tree Nodes.
    /// Generating the code using this structure can be performed in the worst case in O(m*n) 
    /// where m is the number of line in the document and n the number of Nodes.
    /// In the best case if we consider that One node is associated to a line, the code generation will
    /// perform in O(m).
    /// </summary>
    public class LinearNodeSourceCodeMapper : NodeVisitor
    {
        /// <summary>
        /// Visitor Phase
        /// </summary>
        public enum Phase
        {
            /// <summary>
            /// The Linearization Phase.
            /// </summary>
            Linearization,
            /// <summary>
            /// The Phase to deal with removed Nodes
            /// </summary>
            RemovedNodes,
            /// <summary>
            /// The Phase to deal with Function Declaration
            /// </summary>
            FunctionDeclaration,
            /// <summary>
            /// The Phase to attach Nodes Generated by a Factory, to the first parent 
            /// having a position.
            /// </summary>
            FactoryGeneratedNodeAttachment,
        }

        /// <summary>
        /// Linearization mode
        /// </summary>
        public enum Mode
        {
            Normal, //Normal mode
            Cloned, //Cloned nod emode
        }

        /// <summary>
        /// Curent mode.
        /// </summary>
        public Mode LinearMode { get; set; }

        /// <summary>
        /// Will we need a ProcessFactoryGeneratedNodeAttachment Phase ?
        /// </summary>
        private bool NeedProcessFactoryGeneratedNodeAttachment;

        /// <summary>
        /// Inteernal position 0
        /// </summary>
        private static Position Pos0 = new Position(0);

        /// <summary>
        /// The Bit Array of line that must be commented
        /// </summary>
        public BitArray CommentedLines
        {
            get;
            internal set;
        }

        /// <summary>
        /// The Bit Array of line that are associated to a node
        /// </summary>
        public BitArray NodedLines
        {
            get;
            internal set;
        }

        /// <summary>
        /// A map of all Copy token already mapped to a Node.
        /// </summary>
        internal Dictionary<Token, LinearCopyNode> MappedCopyTokens
        {
            get; set;
        }

        public class LineStringSourceText : StringSourceText
        {
            /// <summary>
            /// Lines that participate to this Buffer.
            /// </summary>
            public HashSet<int> Lines
            {
                get;
                set;
            }

            /// <summary>
            /// Is this a relocated buffer ?
            /// </summary>
            public bool Reallocated
            {
                get;
                set;
            }

            /// <summary>
            /// Add a line number that participate to this buffer
            /// </summary>
            /// <param name="i">The line number to be added</param>
            public void AddLine(int i)
            {
                if (Lines == null)
                    Lines = new HashSet<int>();
                Lines.Add(i);
            }
        }

        /// <summary>
        /// Line Informations
        /// </summary>
        public struct LineInfo
        {
            /// <summary>
            /// The List which give for each line the associated Node Index.
            /// </summary>
            public List<int> LineNodes;
            /// <summary>
            /// The Buffer associated to this line.
            /// </summary>
            public LineStringSourceText Buffer;
            /// <summary>
            /// The Buffer associated to this line when it is generated in a function body.
            /// </summary>
            public LineStringSourceText FunctionBodyBuffer;
            /// <summary>
            /// Force the Generator to skip this line, if it has no nodes associated to it.
            /// </summary>
            public bool Skip;
        }
        /// <summary>
        /// The Map which give for each line the associated Node.
        /// </summary>
        public LineInfo[] LineData;

        /// <summary>
        /// The Generator;
        /// </summary>
        public Generator Generator
        {
            get;
            internal set;
        }

        /// <summary>
        /// The Count of Nodes.
        /// </summary>
        public int NodeCount
        {
            get;
            internal set;
        }

        /// <summary>
        /// The Map which gives for a buffer its associated first line number.
        /// </summary>
        public Dictionary<StringSourceText, int> BufferLineMap
        {
            get;
            private set;
        }
        /// <summary>
        /// Set the current phase
        /// </summary>
        public Phase CurrentPhase
        {
            get;
            internal set;
        }

        /// <summary>
        /// The Current Function Declaration Node.
        /// </summary>
        private Node CurrentFunctionDeclNode
        {
            get;
            set;
        }

        /// <summary>
        /// A Linear Generated Dummy Node
        /// </summary>
        internal class LinearGeneratedNode : Compiler.Nodes.Node
        {
            /// <summary>
            /// Empty constructor.
            /// </summary>
            public LinearGeneratedNode()
            {
            }

            /// <summary>
            /// Precalculated positions
            /// </summary>
            public NodePositions Positions
            {
                get;
                set;
            }

            protected override CodeElement InternalCodeElement => null;


            public override bool VisitNode(TypeCobol.Compiler.CodeElements.IASTVisitor astVisitor)
            {
                return false;
            }
        }

        /// <summary>
        /// A Node generated by Linearization
        /// </summary>
        internal class LinearTokensNode : GenericNode<CodeElement>
        {
            public LinearTokensNode(CodeElement CodeElement) : base(CodeElement)
            {
            }

            public override bool VisitNode(IASTVisitor astVisitor)
            {
                return false;
            }
        }

        /// <summary>
        /// A Copy Node generated by Linearization
        /// </summary>
        internal class LinearCopyNode : LinearTokensNode
        {
            public LinearCopyNode(CodeElement CodeElement) : base(CodeElement)
            {
            }

            public override IEnumerable<ITextLine> Lines
            {
                get
                {
                    //Indent the line according to its declaration
                    var linesContent = this.CodeElement.SourceText.Split(new string[] {System.Environment.NewLine}, System.StringSplitOptions.None);

                    foreach (string line in linesContent)
                    {
                        //Only the line containing copy can be badly indented. 
                        string lineText;
                        if (line.IndexOf("COPY", StringComparison.OrdinalIgnoreCase) >= 0)
                        {
                            //Indent this line with the same indentation than the declaring line.
                            lineText = this.CodeElement.ConsumedTokens[0].TokensLine.Text.GetIndent() + line.Trim();
                        }
                        else
                        {
                            //Otherwise generate the other lines as is, with a little extra for the columns 1-7
                            lineText = new string(' ', 7) + line.TrimEnd();
                        }
                        yield return new CobolTextLine(new TextLineSnapshot(-1, lineText, null), ColumnsLayout.CobolReferenceFormat);
                    }
                }
            }
        }

        /// <summary>
        /// Structure that holds Data associated to Nodes
        /// </summary>
        public class NodeData
        {
            /// <summary>
            /// The corresponding Node.
            /// </summary>
            public Node node;
            /// <summary>
            /// Is This node removed?
            /// </summary>
            public bool Removed;
            /// <summary>
            /// If This node is in a function Body, this the Node of the target Function.
            /// </summary>
            public Node FunctionBodyNode;
            /// <summary>
            /// The Last located line of this  node.
            /// </summary>
            public int LastLocatedLine;
            /// <summary>
            /// The Node corresponding to the LastLocatedLine
            /// </summary>
            public Node LastNode;
            /// <summary>
            /// Node's Positions:
            /// - From
            /// - To
            /// - Span on the last line
            /// - Node's Target Line Numbers.
            /// - Node's Target Line Offsets.
            /// </summary>
            public NodePositions Positions;
            /// <summary>
            /// The Buffer where this Node is Generated.
            /// </summary>
            public LineStringSourceText Buffer;
            /// <summary>
            /// From Position in the Source Text Buffer
            /// </summary>
            public Position From;
            /// <summary>
            /// To Position in the Source Text Buffer
            /// </summary>
            public Position To;
        }

        /// <summary>
        /// Data for a Function Declaration Node
        /// </summary>
        public class NodeFunctionData : NodeData
        {
            /// <summary>
            /// The Buffer where a Function Declaration Node is Generated.
            /// </summary>
            public StringSourceText FunctionDeclBuffer;
            /// <summary>
            /// Node Indices associated to Function Declaration.
            /// </summary>
            public List<int> FunctionDeclNodes;
            /// <summary>
            /// The first 1-Based line index of the function body
            /// </summary>
            public int BodyFistLineIndex;
            /// <summary>
            /// The last 1-Based line index of the function body
            /// </summary>
            public int BodyLastLineIndex;
            /// <summary>
            /// The commented Header of a Function declaration
            /// </summary>
            public StringBuilder CommentedHeader;
            /// <summary>
            /// The Fisrt index in the LineIntervalMap of this function
            /// </summary>
            public int LineMapFirstIndex;
            /// <summary>
            /// The Lat Index in the LineIntervalMap of this function
            /// </summary>
            public int LineMapLastIndex;
            /// <summary>
            /// The 1-based, Delta of the Global Storage line in the corresponding Line Mapping if any.
            /// </summary>
            internal int GlobalStorageLineDelta;
            /// <summary>
            /// Constructor
            /// </summary>
            public NodeFunctionData()
            {
                FunctionDeclBuffer = new StringSourceText();
                FunctionDeclNodes = new List<int>();
                CommentedHeader = new StringBuilder();
            }
        }

        /// <summary>
        /// The List Of Node Data indexed by Node.NodeIndex
        /// </summary>
        public List<NodeData> Nodes
        {
            get;
            internal set;
        }

        /// <summary>
        /// The Indices of Function Declaration Nodes.
        /// </summary>
        public List<int> FunctionDeclarationNodeIndices
        {
            get;
            private set;
        }

        /// <summary>
        /// During the linearization Phase this is the last Valid Parent which has a location.
        /// </summary>
        private Node LastLocatedParent
        {
            get;
            set;
        }
        /// <summary>
        /// The 1 based last line of the Last LocatedParent Line.
        /// </summary>
        private int LastLocatedParentLine
        {
            get;
            set;
        }

        /// <summary>
        /// The Constructor
        /// </summary>
        /// <param name="Input">Cobol Text Lines in input</param>
        /// <param name="generator">The Generator</param>
        public LinearNodeSourceCodeMapper(Generator generator)
        {
            LinearMode = Mode.Normal;
            NodeCount = 0;//Count of Nodes Treated.
            Generator = generator;
            int count = generator.CompilationResults.TokensLines.Count;
            CommentedLines = new BitArray(count);
            NodedLines = new BitArray(count);
            LineData = new LineInfo[count];
            FunctionDeclarationNodeIndices = new List<int>();
            BufferLineMap = new Dictionary<StringSourceText, int>();
            MappedCopyTokens = new Dictionary<Token, LinearCopyNode>();
        }

        /// <summary>
        /// Check if at the end the buffer being flushed is generated empty.
        /// A buffer is generated empty if all its target lines are commented
        /// and all nodes in the target lines are commented in block and when the buffer
        /// is Trimmed it is empty.
        /// Such buffer can be ignored.
        /// </summary>
        /// <param name="buffer">The buffer to be tested</param>
        /// <returns>true if the buffer is generated empty</returns>
        internal bool IsGeneratedEmptyBuffer(StringSourceText buffer)
        {
            if (BufferLineMap.ContainsKey(buffer))
            {
                //For each contigüous line having the same buffer
                for (int i = BufferLineMap[buffer]; i < LineData.Length && LineData[i].Buffer == buffer; i++)
                {
                    if (LineData[i].LineNodes == null)
                        return false;
                    //Each Node of the line must be commented
                    foreach (int node_index in LineData[i].LineNodes)
                    {
                        if (Nodes[node_index].node.Comment == null ? false : !Nodes[node_index].node.Comment.Value)
                            return false;
                    }
                }
                if (Generator.Layout == ColumnsLayout.CobolReferenceFormat)
                {//Cobol Format
                    for (int i = 0, j = 0; i < buffer.Size; i++, j++)
                    {
                        char c = buffer[i];
                        if (!Char.IsWhiteSpace(c) && c != '\r' && c != '\n')
                        {
                            if (j >= 6 && j < 73)
                                return false;
                        }
                        if (c == '\n')
                            j = 0;
                    }
                }
                else
                {
                    //Now the buffer content must contains only whitespace, carriage return or line feed characters.
                    for (int i = 0; i < buffer.Size; i++)
                    {
                        char c = buffer[i];
                        if (!Char.IsWhiteSpace(c) && c != '\r' && c != '\n')
                            return false;
                    }
                }                
                return true;
            }
            return false;
        }

        /// <summary>
        /// The Function Declaration Processing Phase. The Purpose of this phase is to associate
        /// to a FunctionDeclaration Node all its nodes that belongs to its body.
        /// It also determines the starting line and the ending line in the source code of the
        /// function body.
        /// <param name="node">The node that belongs to a Function Body</param>
        /// <returns>True if children of the given node must be visited, false otherwise</returns>
        /// </summary>
        private bool ProcessFunctionDeclaration(Node node)
        {
            //Function Node Data
            NodeFunctionData funData = (NodeFunctionData)Nodes[CurrentFunctionDeclNode.NodeIndex];
            //Create a New Data
            NodeData data = null;
            bool bHasCodeElement = node is ParameterEntry ? false : 
                (node.CodeElement == null || node.CodeElement.ConsumedTokens == null) ? false : (node.CodeElement.ConsumedTokens.Count > 0 || node is Generated == false);
            if (!bHasCodeElement)
            {
                //No Code Element ==> certainly a Generated node                
                node.NodeIndex = NodeCount++;//Give to this node its Index.    
                data = new NodeData();
                data.node = node;
                Nodes.Add(data);
            }
            else
            {//If The Node has positions then linearize it
                ProcessLinearization(node, true);
                if (node.NodeIndex >= 0)
                {
                    data = Nodes[node.NodeIndex];
                    if (funData.BodyFistLineIndex == 0)
                    {//Remember the first the first line of the function body
                        funData.BodyFistLineIndex = data.Positions.LineNumbers[0];
                    }
                    //Track the last line of the function body.
                    funData.BodyLastLineIndex = data.Positions.LineNumbers[0];
                }
            }
            if (node.NodeIndex > 0)
            {
                //Associate the Function Node
                if (data != null) data.FunctionBodyNode = CurrentFunctionDeclNode;
                //Add the node to the Function Decl nodes list
                funData.FunctionDeclNodes.Add(node.NodeIndex);
            }
            return true;
        }

        /// <summary>
        /// Determine if it is possible to Insert before the given node.
        /// </summary>
        /// <param name="beforeNode">The node to be checked</param>
        /// <returns>true if it is possible to insert before the node, false otherwise.</returns>
        bool CanInsertBeforeNode(Node beforeNode)
        {
            //Debug.Assert(beforeNode != null);
            if (!(beforeNode != null))
                return false;
            //Debug.Assert(beforeNode.NodeIndex > 0);
            if (!(beforeNode.NodeIndex > 0))
                return false;
            //Debug.Assert(Nodes[beforeNode.NodeIndex].Buffer != null);
            if (!(Nodes[beforeNode.NodeIndex].Buffer != null))
                return false;
            //Debug.Assert(Nodes[beforeNode.NodeIndex].Positions != null);
            if (!(Nodes[beforeNode.NodeIndex].Positions != null))
                return false;
            //Debug.Assert(Nodes[beforeNode.NodeIndex].Positions.LineNumbers.Count > 0);
            if (!(Nodes[beforeNode.NodeIndex].Positions.LineNumbers.Count > 0))
                return false;
            //Debug.Assert(Nodes[beforeNode.NodeIndex].Positions.LineOffsets.Count > 0);
            if (!(Nodes[beforeNode.NodeIndex].Positions.LineOffsets.Count > 0))
                return false;
            //Debug.Assert(Nodes[beforeNode.NodeIndex].From != null);
            if (!(Nodes[beforeNode.NodeIndex].From != null))
                return false;
            //Debug.Assert(Nodes[beforeNode.NodeIndex].To != null);
            if (!(Nodes[beforeNode.NodeIndex].To != null))
                return false;
            return true;
        }
        /// <summary>
        /// Insert a Node bafore an another Node.
        /// </summary>
        /// <param name="theNode"></param>
        /// <param name="beforeNode"></param>
        /// <returns>true if the insertion have been performed, false otherwise</returns>
        private bool InsertNodeBeforeNode(Node theNode, Node beforeNode)
        {
            Debug.Assert(theNode != null);
            if (!(theNode != null))
                return false;
            Debug.Assert(beforeNode != null);
            if (!(beforeNode != null))
                return false;
            Debug.Assert(beforeNode.NodeIndex > 0);
            if (!(beforeNode.NodeIndex > 0))
                return false;
            Debug.Assert(theNode.NodeIndex > 0);
            if (!(theNode.NodeIndex > 0))
                return false;
            Debug.Assert(Nodes[beforeNode.NodeIndex].Buffer != null);
            if (!(Nodes[beforeNode.NodeIndex].Buffer != null))
                return false;
            Debug.Assert(Nodes[beforeNode.NodeIndex].Positions != null);
            if (!(Nodes[beforeNode.NodeIndex].Positions != null))
                return false;
            Debug.Assert(Nodes[beforeNode.NodeIndex].Positions.LineNumbers.Count > 0);
            if (!(Nodes[beforeNode.NodeIndex].Positions.LineNumbers.Count > 0))
                return false;
            Debug.Assert(Nodes[beforeNode.NodeIndex].Positions.LineOffsets.Count > 0);
            if (!(Nodes[beforeNode.NodeIndex].Positions.LineOffsets.Count > 0))
                return false;
            Debug.Assert(Nodes[beforeNode.NodeIndex].From != null);
            if (!(Nodes[beforeNode.NodeIndex].From != null))
                return false;
            Debug.Assert(Nodes[beforeNode.NodeIndex].To != null);
            if (!(Nodes[beforeNode.NodeIndex].To != null))
                return false;

            //Determine the Line number of the before line.
            int before_line = Nodes[beforeNode.NodeIndex].Positions.LineNumbers[0] - 1;
            //Add the node to the same line
            int insertIndex = LineData[before_line].LineNodes.IndexOf(beforeNode.NodeIndex);
            LineData[before_line].LineNodes.Insert(insertIndex, theNode.NodeIndex);
            //The Node is Inserted at the beginning of the before node
            Nodes[theNode.NodeIndex].Buffer = Nodes[beforeNode.NodeIndex].Buffer;
            Nodes[theNode.NodeIndex].From = Nodes[beforeNode.NodeIndex].From;
            Nodes[theNode.NodeIndex].To = Nodes[beforeNode.NodeIndex].From;
            //Give to the Node its new span
            Nodes[theNode.NodeIndex].Positions = new NodePositions(
                Nodes[beforeNode.NodeIndex].Positions.From,
                Nodes[beforeNode.NodeIndex].Positions.From,
                Nodes[beforeNode.NodeIndex].Positions.From,
                new List<int>() { Nodes[beforeNode.NodeIndex].Positions.LineNumbers[0] },
                new List<int>() { Nodes[beforeNode.NodeIndex].Positions.LineOffsets[0] }
                );
            //We must insert a NewLine

            return true;
        }

        /// <summary>
        /// Insert a Node after an another Node.
        /// </summary>
        /// <param name="theNode"></param>
        /// <param name="afterNode"></param>
        /// <returns>true if the insertion have been performed, false otherwise</returns>
        private bool InsertNodeAfterNode(Node theNode, Node afterNode)
        {
            Debug.Assert(theNode != null);
            if (!(theNode != null))
                return false;
            Debug.Assert(afterNode != null);
            if (!(afterNode != null))
                return false;
            Debug.Assert(afterNode.NodeIndex >= 0);
            if (!(afterNode.NodeIndex >= 0))
                return false;
            Debug.Assert(theNode.NodeIndex > 0);
            if (!(theNode.NodeIndex > 0))
                return false;
            Debug.Assert(Nodes[afterNode.NodeIndex].Buffer != null);
            if (!(Nodes[afterNode.NodeIndex].Buffer != null))
                return false;
            Debug.Assert(Nodes[afterNode.NodeIndex].Positions != null);
            if (!(Nodes[afterNode.NodeIndex].Positions != null))
                return false;
            Debug.Assert(Nodes[afterNode.NodeIndex].Positions.LineNumbers.Count > 0);
            if (!(Nodes[afterNode.NodeIndex].Positions.LineNumbers.Count > 0))
                return false;
            Debug.Assert(Nodes[afterNode.NodeIndex].Positions.LineOffsets.Count > 0);
            if (!(Nodes[afterNode.NodeIndex].Positions.LineOffsets.Count > 0))
                return false;
            Debug.Assert(Nodes[afterNode.NodeIndex].From != null);
            if (!(Nodes[afterNode.NodeIndex].From != null))
                return false;
            Debug.Assert(Nodes[afterNode.NodeIndex].To != null);
            if (!(Nodes[afterNode.NodeIndex].To != null))
                return false;

            //Determine the Line number of the before line.
            int before_line = Nodes[afterNode.NodeIndex].Positions.LineNumbers[0] - 1;
            //Add the node to the same line
            LineData[before_line].LineNodes.Add(theNode.NodeIndex);
            //The Node is Inserted at the beginning of the before node
            Nodes[theNode.NodeIndex].Buffer = Nodes[afterNode.NodeIndex].Buffer;
            Nodes[theNode.NodeIndex].From = Nodes[afterNode.NodeIndex].To;
            Nodes[theNode.NodeIndex].To = Nodes[afterNode.NodeIndex].To;
            //Give to the Node its new span
            Nodes[theNode.NodeIndex].Positions = new NodePositions(
                Nodes[afterNode.NodeIndex].Positions.To,
                Nodes[afterNode.NodeIndex].Positions.To,
                Nodes[afterNode.NodeIndex].Positions.Span,
                new List<int>() { Nodes[afterNode.NodeIndex].Positions.LineNumbers[^1] },
                new List<int>() { Nodes[afterNode.NodeIndex].Positions.LineOffsets[^1] }
                );
            //First generate a new line befor this node
            theNode.SetFlag(Node.Flag.FactoryGeneratedNodeWithFirstNewLine, true);
            return true;
        }

        /// <summary>
        /// This Phase deals with node created by the Generator Factory thus nodes
        /// that cannot be associated to a Position. The strategy is to associate these nodes
        /// to the last line of the first parent node which has positions.
        /// </summary>
        /// <param name="node">The node</param>
        /// <returns>true</returns>
        private bool ProcessFactoryGeneratedNodeAttachment(Node node)
        {
            if (node.IsFlagSet(Node.Flag.FactoryGeneratedNode))
            {   //This Node has been generated by a factory
                //Humm .. attach it to the last valid parent
                //No Code Element ==> certainly a Generated node                
                node.NodeIndex = NodeCount++;//Give to this node its Index.    
                NodeData data_node = new NodeData();
                data_node.node = node;
                Nodes.Add(data_node);
                Node parent = GetFirstParentWithPosition(node);                   
                if (node.IsFlagSet(Node.Flag.FactoryGeneratedNodeKeepInsertionIndex))
                {//So we must keep the insertion index                    
                    Node beforeNode = null;
                    int index = node.Parent.IndexOf(node);
                    while (index != 0 && index != (node.Parent.Children.Count - 1))
                    {
                        beforeNode = node.Parent.Children[index++];
                        //Ignore Functions Declarations.
                        if(!(beforeNode is TypeCobol.Compiler.Nodes.FunctionDeclaration) && beforeNode != node)
                            break;
                    }
                    if (index != 0 && index != (node.Parent.Children.Count - 1))
                    {
                        if (InsertNodeBeforeNode(node, beforeNode))
                            return true;
                    }
                    if (index != 0 && index == (node.Parent.Children.Count - 1) && beforeNode != null)
                    {//Check if we can insert before this last node
                        if(CanInsertBeforeNode(beforeNode))
                        {
                            if (InsertNodeBeforeNode(node, beforeNode))
                            {
                                node.SetFlag(Node.Flag.FullyGenerateRecursivelyFactoryGeneratedNode, true, true);
                                return false;
                            }                                
                        }
                    }
                    if (node.Parent.Children.Count > 1 && index == (node.Parent.Children.Count - 1))
                    {
                    }
                    else
                    {
                        //We must insert after the parent.                        
                        if (node.Parent.IsFlagSet(Node.Flag.FactoryGeneratedNodeKeepInsertionIndex) && node.Children.Count == 0)
                        {
                            //It's parent is already a repositionned node, and this node has no children.
                            node.SetFlag(Node.Flag.FactoryGeneratedNodeKeepInsertionIndex, false);
                            return true;
                        }
                        //Look for the first parent with a position
                        Node valid_parent = node.Parent;
                        if (valid_parent != null && (valid_parent.NodeIndex < 0 || Nodes[valid_parent.NodeIndex].Positions == null))
                            valid_parent = valid_parent.Parent;
                        if (InsertNodeAfterNode(node, valid_parent ?? node.Parent))
                            return true;
                    }
                }           
                //Fall to the default case insert the Node at the last line of the parent node.
                int lastLine = Nodes[parent.NodeIndex].LastLocatedLine;
                Node lastNode = Nodes[parent.NodeIndex].LastNode;
                if (LineData[lastLine - 1].LineNodes == null)
                    LineData[lastLine - 1].LineNodes = new List<int>();
                if ((lastNode is TypeCobol.Compiler.Nodes.End) && lastNode.CodeElement.Type == Compiler.CodeElements.CodeElementType.ProgramEnd)
                    //This a ProgramEnd Node ==> add before the last ProgramEnd node
                    LineData[lastLine - 1].LineNodes.Insert(LineData[lastLine - 1].LineNodes.Count - 1, node.NodeIndex);
                else
                    LineData[lastLine - 1].LineNodes.Add(node.NodeIndex);
            }
            return true;
        }

        /// <summary>
        /// The Linearization Phase.
        /// <param name="node">The node to linearize</param>
        /// <param name="functionBody">true if the node belongs to a function body, false otherwise</param>
        /// <returns>True if children of the given node must be visited, false otherwise</returns>
        /// </summary>
        private bool ProcessLinearization(Node node, bool functionBody = false)
        {
            //During the Linearization Phase, collect data, index of all Nodes.
            //1) Get the Positions of the Node: 
            //  Tuple(from,to,span, lineNumbers, lineOffsets);
            if (node.IsFlagSet(Node.Flag.UseGlobalStorage))
            {
                UseGlobalStorageSection = true;
            }

            if (node.CodeElement != null && node.CodeElement.Type == CodeElementType.GlobalStorageSectionHeader && node.IsFlagSet(Node.Flag.IsCloned))
            {
                //Remember the Global Storage Section node.
                this.ClonedGlobalStorageSection = (GlobalStorageSection)node;
            }
            NodePositions positions = this.Generator.FromToPositions(node);
            if (positions == null)
            { //Node without positions probably a generated node.
                node.NodeIndex = -1;
                if (node.IsFlagSet(Node.Flag.FactoryGeneratedNode))
                {   //This is a Node Generated by The Skeleton Factory Process
                    //=>Indicate that we will need a FactoryGeneratedNodeAttachment Phase
                    NeedProcessFactoryGeneratedNodeAttachment = true;
                }
                return true;
            }
            if (positions.LineNumbers.Count == 0)
            {   //This must be a Node in an imported COPY it has no lines associated to it
                //So We must First try to create a COPY Node so that we can capture the COPY Line.
                if (node.IsInsideCopy())
                {   //Determine that the COPY instruction is within the current document, if so
                    //Create a node with Token positions.
                    if (node.CodeElement.FirstCopyDirective != null)
                    {
                        int copyLine = node.CodeElement.FirstCopyDirective.COPYToken.Line;
                        if (copyLine > 0 && copyLine <= this.Generator.CompilationResults.CobolTextLines.Count)
                        {
                            ICobolTextLine copyTextLine = this.Generator.CompilationResults.CobolTextLines[copyLine - 1];
                            var copyToken = ((Compiler.Parser.CodeElementsLine)copyTextLine).SourceTokens.FirstOrDefault(
                                t => t == node.CodeElement.FirstCopyDirective.COPYToken);
                            if (copyToken != null && !MappedCopyTokens.ContainsKey((copyToken)))
                            {//We got one ==>
                                //Collect all COPY Tokens
                                var consumedTokens = node.CodeElement.FirstCopyDirective.ConsumedTokens;
                                var copyTokens = consumedTokens.SelectedTokensOnSeveralLines.SelectMany(tokenLine => tokenLine).ToList();

                                //A Copy of a Commented node must have its lines commented also.
                                bool bCopyCommented = node.Comment.HasValue && node.Comment.Value;
                                if (bCopyCommented)
                                {
                                    int copyFirstLineIndex = consumedTokens.FirstLineIndex;
                                    int copyLineCount = consumedTokens.SelectedTokensOnSeveralLines.Length;
                                    for (int i = 0; i < copyLineCount; i++)
                                    {
                                        CommentedLines[copyFirstLineIndex + i] = true;
                                    }
                                }

                                //Create node with the COPY Tokens
                                LinearCopyNode copyNode = new LinearCopyNode(new Qualifier.TokenCodeElement(copyTokens));
                                //Just add it has children to the current node.
                                node.Add(copyNode);                                    
                                if (bCopyCommented)
                                {//This a commented COPYs
                                    if (node.Parent != null)
                                    {//Inform the parent that it has a COPY node here
                                        this.Generator.ErasedNodes.Add(copyNode);
                                        node.Parent.SetFlag(Node.Flag.InsideTypedefFromCopy, true, true);
                                        copyNode.SetFlag(Node.Flag.IsTypedefCopyNode, true);
                                    }
                                }
                                MappedCopyTokens[copyToken] = copyNode;
                            }
                        }
                    }
                }
                node.NodeIndex = -1;
                return true;
            }
            if (positions.From > positions.To)
            {   //This is a very strange node that I encountered with position (from > to)
                //I encountered this situation with tests files like:
                //CCC1B045.PGM, CCTF0011.PGM, CCTZ015B, CCTZ0300B, etc..
                //With a DataDescription Node.
                //I Ignore this kind of Node, it is a work around because it seems that
                //such nodes are considered as end of file marking nodes without any code
                //attached to.
                return true;
            }
            bool isFunctionDecl = node is FunctionDeclaration;//Detect Function Declaration
            //If function Node data is instanceof NodeFunctionData class otherwise NodeData class
            NodeData data = isFunctionDecl ? new NodeFunctionData() : new NodeData();
            data.node = node;//Indicate the related Node 
            data.Positions = positions; //Store Node's Positions.          
            node.NodeIndex = NodeCount++;//Give to this node its Index.            

            //Is This Node marked as to be commented ?
            bool bCommented = node.Comment.HasValue ? node.Comment.Value : false;
            LineStringSourceText buffer = null;
            //The first line number of the target buffer
            int lineindex_buffer = -1;
            foreach (int i in data.Positions.LineNumbers)
            {//For each line concerned by the Node
                int lineIndex = i - 1;//Zero based Index Line Number
                NodedLines[lineIndex] = true;//Now this line is associated to at leat one node.

                //This line is commented;
                if (bCommented)
                {//This node must be commented ==> Mark all its lines that must be commented.
                    CommentedLines[lineIndex] = true;
                }
                //Associate the node to it's line --> Add the Node to list of associated node for the line.
                if (LineData[lineIndex].LineNodes == null)
                {
                    LineData[lineIndex].LineNodes = new List<int>();
                }
                LineData[lineIndex].LineNodes.Add(node.NodeIndex);
                //Associated all Lines to the Buffer of the First line in the list
                if (buffer == null)
                {   //No Buffer allocated yet -> Allocate a new one if current line does not already has one.
                    buffer = functionBody ? LineData[lineIndex].FunctionBodyBuffer : LineData[lineIndex].Buffer;
                    if (buffer == null)
                    {
                        buffer = new LineStringSourceText();
                        BufferLineMap[buffer] = lineIndex;
                    }
                    lineindex_buffer = BufferLineMap[buffer];
                }
                //Associate its buffer to the current line depending if the current Node is A FunctionDeclaration
                if (functionBody)
                {
                    LineData[lineIndex].FunctionBodyBuffer = buffer;                    
                }
                else
                {
                    LineData[lineIndex].Buffer = buffer;                    
                }
                //Add the participating line buffer
                buffer.AddLine(lineIndex);
                //Propagate Comment from buffer line index to current line.
                //That is to say mark all line concerned by a Commented Node as commented.
                if (bCommented)
                {
                    for (int k = lineindex_buffer; k < lineIndex; k++)
                        CommentedLines[k] = true;
                }
            }
            //Associate this node to its buffer
            data.Buffer = buffer;
            //Update the positions by translating the position to the real position in the source document.
            //The source document is the document which contains the Full original source code
            int line_from = data.Positions.From - 1;
            int line_to = data.Positions.To;
            int span = data.Positions.Span;
            List<int> lines = data.Positions.LineNumbers;
            List<int> line_offsets = data.Positions.LineOffsets;
            SourceDocument.SourceLine lineindex_srcline = Generator.TargetDocument[lineindex_buffer];
            SourceDocument.SourceLine line = Generator.TargetDocument[lines[0] - 1];
            int delta = line.From - lineindex_srcline.From;
            data.Positions = new NodePositions(delta + line_from, delta + line_to, span, lines, line_offsets);
            //Add Node's data to the list of all Node Data
            Nodes.Add(data);
            //------------------------------------------------------------------------------
            // Special case for a Function Declaration Node
            // Swith temporarly to the FunctionDeclaration
            // Phase and visit each child node of the Function's body node.
            //-------------------------------------------------------------------------------
            if (isFunctionDecl && CurrentPhase == Phase.Linearization)
            {
                //Save the Current Phase
                Phase savePhase = CurrentPhase;
                //Switch to Function Declaration Phase
                CurrentPhase = Phase.FunctionDeclaration;
                //The Current Function Node
                CurrentFunctionDeclNode = node;
                //Add to the List of encountered function declaration the Function Declaration Node's Index
                FunctionDeclarationNodeIndices.Add(node.NodeIndex);
                //Visit Each Function body Node.     
                Node endNode = null;//Capture the function end node                
                int nodeCount = 0;
                foreach (Node body_node in node.Children)
                {
                    if (nodeCount != node.ChildrenCount - 1)
                    {
                        Visit(body_node);
                    }
                    else
                    {
                        //Save to process later
                        endNode = body_node;
                    }

                    nodeCount++;
                }                                                                                                         

                if (node.Children.Count > 0)
                {
                    int curEnd = ((NodeFunctionData)Nodes[CurrentFunctionDeclNode.NodeIndex]).BodyLastLineIndex;
                    int orgEnd = node.Children.OfType<Codegen.Nodes.ProgramEnd>().Single().OriginalLine - 1;
                    if (orgEnd > curEnd && curEnd > 0)
                    {
                        //Process everything that hasn't been processed as node and is between the last node of the procedure division and the end-declare
                        ((NodeFunctionData)Nodes[CurrentFunctionDeclNode.NodeIndex]).BodyLastLineIndex = orgEnd;
                        for (int i = curEnd + 1; i < orgEnd; i++)
                        {
                            var tl = Generator.CompilationResults.TokensLines[i - 1];
                            //Any line that hasn't been processed yet is necessarily a comment
                            LinearTokensNode tokensNode = new LinearTokensNode(new Qualifier.TokenCodeElement(tl.SourceTokens));
                            tokensNode.Comment = true;
                            this.Generator.ErasedNodes.Add(tokensNode);
                            curEnd = ((NodeFunctionData)Nodes[CurrentFunctionDeclNode.NodeIndex]).BodyLastLineIndex;
                            Visit(tokensNode);
                            //Don't add nodes that have a NodeIndex at 0 (e.G. node that contain only a SpaceSeparator token)
                            if (tokensNode.NodeIndex > 0 && tokensNode.CodeElement.ConsumedTokens.Count > 0) 
                                node.Add(tokensNode, node.ChildrenCount - 1);
                            else
                            {
                                ((NodeFunctionData) Nodes[CurrentFunctionDeclNode.NodeIndex]).BodyLastLineIndex =
                                    curEnd;
                            }
                        }                        
                    }
                }

                if (endNode != null)
                {
                    Visit(endNode);
                }

                //Restore the phase
                CurrentPhase = savePhase;
                return false;//Don't deal with its Children
            }
            return true;
        }

        public GlobalStorageSection ClonedGlobalStorageSection { get; set; }

        public bool UseGlobalStorageSection { get; set; }

        /// <summary>
        /// Collect all lines that have not been associated to a Node during Function Declaration
        /// processing phase. The lines are then associated to Dummy nodes, that have a buffer containing
        /// the source code of the line.
        /// </summary>
        /// <param name="funData">The Function Declaration Data</param>
        private void CollectFunctionBodyUnNodedLines(NodeFunctionData funData)
        {            
            //Compute valid relocation insertion points
            Tuple<int[], int[]> insertLines = ComputeFunctionBodyInsertionLines(funData);
            var Input = Generator.CompilationResults.TokensLines;
            bool bInsideComment = false;
            int offset = 0;
            for (int i = funData.BodyFistLineIndex + 1; i < funData.BodyLastLineIndex; i++)
            {//For each line number in the function declaration body                
                if (LineData[i - 1].LineNodes == null)
                {//No Nodes associated to the line.                    
                    //Search valid insertion point
                    int j = Array.BinarySearch(insertLines.Item1, i);
                    if (j < 0)
                        continue;///??? -- No Valid insertion point --> hum... this not a well formed function declaration
                    int insert_index = insertLines.Item2[j];  
                    if (insert_index < 0)
                    {   //This position correspond to a line with no nodes associated to it
                        insertLines.Item2[j] = -insert_index;                        
                    }
                    //The insert index in the list of nodes
                    insert_index = insertLines.Item2[j] + offset;
                    //Create a specific Node
                    LinearGeneratedNode dummy_node = new LinearGeneratedNode();
                    //Mark it as a specific
                    dummy_node.SetFlag(Node.Flag.ExtraGeneratedLinearNode, true);
                    //Give to the node its index
                    dummy_node.NodeIndex = NodeCount++;
                    //Create Node data for it
                    NodeData data = new NodeData();
                    //Set the target Node
                    data.node = dummy_node;
                    //Give it invalid (Fromn to) positions
                    //--> the text of the line will be added at the end of the generated buffer
                    data.From = Pos0;
                    data.To = Pos0;
                    //Set the associated Function Declaration Node
                    data.FunctionBodyNode = funData.node;
                    //Create the source code buffer in which the text of the line will be stored
                    data.Buffer = new LineStringSourceText();
                    data.Buffer.Reallocated = true;
                    //Read the line of the text in the buffer
                    TypeCobol.Compiler.Scanner.ITokensLine line = Input[i - 1];
                    data.Buffer.Insert(line.Text, data.Buffer.Size, data.Buffer.Size);
                    data.Buffer.Insert(Environment.NewLine, data.Buffer.Size, data.Buffer.Size);
                    //Add the Global Node list this new Node
                    Nodes.Add(data);
                    //------------------------------------------------------------------------------
                    // This is a fix for: https://github.com/TypeCobolTeam/TypeCobol/issues/1014
                    // The main idea is to insert the dummy node after the first non generated valid
                    // node having a valid position. 
                    // Thus to give to this dummy node the line of the first previous valid non
                    // generated node having a position.
                    //-------------------------------------------------------------------------------
                    bool bGotOne = false;
                    int lineGot = i;
                    for (int k = i - 1; k >= funData.BodyFistLineIndex + 1 && !bGotOne; k--)
                    {
                        if (LineData[k - 1].LineNodes != null)
                        {
                            for (int m = 0; m < LineData[k - 1].LineNodes.Count && !bGotOne; m++)
                            {
                                int node = LineData[k - 1].LineNodes[m];
                                NodeData nodedata = Nodes[node];
                                if (!(nodedata.node is LinearGeneratedNode))
                                {
                                    var nodePos = nodedata.Positions;
                                    if (nodePos != null)
                                    {
                                        bGotOne = true;
                                        lineGot = k;
                                    }
                                }
                            }
                        }
                    }

                    if (line.SourceTokens.Any(st => st.TokenType == TokenType.MULTILINES_COMMENTS_START))
                        bInsideComment = true;

                    //------------------------------------------------------------------------------
                    //Set for the list its new associated node
                    if (LineData[lineGot - 1].LineNodes == null && !bInsideComment)
                    {
                        LineData[lineGot - 1].LineNodes = new List<int>();
                    }
                    else if (bInsideComment)
                    {
                        this.CommentedLines[i - 1] = true;
                    }

                    if (LineData[lineGot - 1].LineNodes != null && !bInsideComment)
                        LineData[lineGot - 1].LineNodes.Add(dummy_node.NodeIndex);

                    if (line.SourceTokens.Any(st => st.TokenType == TokenType.MULTILINES_COMMENTS_STOP))
                        bInsideComment = false;

                    //Set associated source text buffer of the line
                    if (lineGot != i)
                    {
                        LineData[lineGot - 1].FunctionBodyBuffer = LineData[lineGot - 1].Buffer = data.Buffer;
                        data.Buffer.AddLine(i - 1);
                        //Skip the current line if not needed.
                        LineData[i - 1].Skip = true;
                    }
                    //Inset the Function nodes list this new node at the right insertion index
                    funData.FunctionDeclNodes.Insert(insert_index, dummy_node.NodeIndex);
                    //Increase insertion offset
                    offset++;
                    //Create valid positions for the new node.
                    int from = 0;//From the beginning of the buffer
                    int to = data.Buffer.Size;//To the end of the buffer
                    int span = 0;
                    List<int> lines = new List<int>(){ lineGot };//Line number
                    List<int> offsets = new List<int>(){0};//Line number start at offse 0
                    NodePositions pos = new NodePositions(from, to, span, lines, offsets);
                    dummy_node.Positions = pos; 
                }
            }
        }

        /// <summary>
        /// Relocate all Function declaration nodes that don't have positions.
        /// Nodes without positions are relocated in the line having the last valid buffer.
        /// </summary>
        /// <param name="funData">The Function Declaration Data</param>
        private void RelocateFunctionBodyNoPositionNodes(NodeFunctionData funData)
        {
            //The last line of the function declaration
            int lastBufferLineNumber = funData.Positions.LineNumbers.Count > 0 ? funData.Positions.LineNumbers[^1] :-1;
            for (int j = 0; j < funData.FunctionDeclNodes.Count; j++)
            {//For each Node in the function declaration body
                NodeData node_data = Nodes[funData.FunctionDeclNodes[j]];
                //Get its positions
                NodePositions positions = 
                    node_data.node.IsFlagSet(Node.Flag.ExtraGeneratedLinearNode) ?
                    ((LinearGeneratedNode)node_data.node).Positions : this.Generator.FromToPositions(node_data.node);
                if (positions != null && node_data.Buffer != null)
                {//If the Node has positions and it is associated to a buffer
                    //The keep the the first line number having a valid buffer
                    lastBufferLineNumber = positions.LineNumbers[0];
                }
                else if (positions == null && lastBufferLineNumber > 0)
                {   //The node has no positions but we know a valid last line number having a valid buffer
                    //Put this node in the same line then the last know buffer
                    if (LineData[lastBufferLineNumber - 1].LineNodes == null)
                        LineData[lastBufferLineNumber - 1].LineNodes = new List<int>();
                    LineData[lastBufferLineNumber - 1].LineNodes.Add(funData.FunctionDeclNodes[j]);
                    //Mark this node as coming from a NoPosGeneratedNode handling.
                    node_data.node.SetFlag(Node.Flag.NoPosGeneratedNode, true);
                }
                else if (positions == null && lastBufferLineNumber < 0)
                {//The Node has no position and dont have a valid last line number witha buffer
                    //Hum... ==> This not a well-formed function declaration.
                    Debug.Assert(lastBufferLineNumber > 0);
                }
                if (j == funData.FunctionDeclNodes.Count - 1)
                {//Mark End Function declaration Node.
                    node_data.node.SetFlag(Node.Flag.EndFunctionDeclarationNode, true);
                }
            }
        }

        /// <summary>
        /// Compute Insertion lines of a Function declaration Body, that is to say line numbers
        /// that begin an instruction : a node.
        /// </summary>
        /// <param name="funData">The Dunction data</param>
        /// <returns>A Tuple(LineNumbers, Insertion Positions)</returns>
        private Tuple<int[], int[]> ComputeFunctionBodyInsertionLines(NodeFunctionData funData)
        {
            List<int> lineNumbers = new List<int>();//List of line numbers where insertion can be done.
            List<int> insertPoints = new List<int>();//List of Intertion point (index) where a node can be inserted.            
            for (int j = 0; j < funData.FunctionDeclNodes.Count; j++)
            {//For each node in the function declaration body.
                NodeData node_data = Nodes[funData.FunctionDeclNodes[j]];
                NodePositions positions = this.Generator.FromToPositions(node_data.node);
                if (positions != null)
                {//A Node with positions
                    if (!lineNumbers.Contains(positions.LineNumbers[0]))
                    {
                        //Insert interval to the previous insertion point.
                        if (lineNumbers.Count > 0)
                        {
                            int prevPoint = insertPoints[insertPoints.Count - 1];
                            for (int i = lineNumbers[lineNumbers.Count - 1] + 1; i < positions.LineNumbers[0]; i++)
                            {   //Each line numbers not associated to a node must be associated to the last valid  insertion point.
                                //Such insertion point is added with negative value to distinguish it from a valid insertion point.
                                lineNumbers.Add(i);
                                insertPoints.Add(-(prevPoint + 1));                        
                            }
                        }
                        //Add the line number and its position to valid number and insertion point lists.
                        lineNumbers.Add(positions.LineNumbers[0]);
                        insertPoints.Add(j);
                    }
                }
            }
            Tuple<int[], int[]> insertLines = new Tuple<int[], int[]>(lineNumbers.ToArray(), insertPoints.ToArray());
            return insertLines;
        }

        /// <summary>
        /// Create All SourceTextBuffer Content associated to Nodes and Create
        /// Node's positions inside the associated buffer.
        /// 
        /// </summary>
        private void CreateNodeSourceTextBufferContents()
        {
            var Input = Generator.CompilationResults.TokensLines;
            StringWriter sw = new StringWriter();
            for (int i = 0; i < LineData.Length; i++)
            {
                if (LineData[i].Buffer != null)
                {
                    TypeCobol.Compiler.Scanner.ITokensLine line = Input[i];
                    LineData[i].Buffer.Insert(line.Text, LineData[i].Buffer.Size, LineData[i].Buffer.Size);
                    LineData[i].Buffer.Insert(Environment.NewLine, LineData[i].Buffer.Size, LineData[i].Buffer.Size);
                    LineData[i].Buffer.AddLine(i);
                }
                //Deal with Function buffer
                if (LineData[i].FunctionBodyBuffer != null)
                {
                    TypeCobol.Compiler.Scanner.ITokensLine line = Input[i];
                    LineData[i].FunctionBodyBuffer.Insert(line.Text, LineData[i].FunctionBodyBuffer.Size, LineData[i].FunctionBodyBuffer.Size);
                    LineData[i].FunctionBodyBuffer.Insert(Environment.NewLine, LineData[i].FunctionBodyBuffer.Size, LineData[i].FunctionBodyBuffer.Size);
                    LineData[i].FunctionBodyBuffer.AddLine(i);
                }
            }
            //Create All Node's positions in the corresponding source text buffer.
            for (int i = 0; i < Nodes.Count; i++)
            {
                if (Nodes[i].Positions != null)
                {//Only for Nodes with positions
                    Position from = new Position(Nodes[i].Positions.From);
                    Position to = new Position(Nodes[i].Positions.To);
                    Nodes[i].Buffer.AddPosition(from);//from position
                    Nodes[i].Buffer.AddPosition(to);//To Pos
                    Nodes[i].From = from;
                    Nodes[i].To = to;
                }
            }
        }

        /// <summary>
        /// For all Function declarations, this method relocates all lines within the function declaration body
        /// that have not been relocated when the function declaration body has been relocated.
        /// This by Dealing with all lines that are not attached to a node.
        /// And relocates nodes without positions
        /// 
        /// </summary>
        private void CompleteFunctionDeclarationLinesRelocation()
        {
            foreach (int fun_index in FunctionDeclarationNodeIndices)
            {
                NodeFunctionData funData = (NodeFunctionData)Nodes[fun_index];
                CollectFunctionBodyUnNodedLines(funData);
                RelocateFunctionBodyNoPositionNodes(funData);
            }
        }

        /// <summary>
        /// Accept this Node to be visited.
        /// </summary>
        /// <param name="node">The Node to be visited</param>
        public void Accept(Node node)
        {
            Nodes = new List<NodeData>();
            //First Phase Linearization
            CurrentPhase = Phase.Linearization;            
            Visit(node);
            if (LinearMode == Mode.Normal)
            {
                //Second Phase Removed Nodes
                CurrentPhase = Phase.RemovedNodes;
                foreach (Node erased_node in this.Generator.ErasedNodes)
                {
                    if (!erased_node.IsFlagSet(Node.Flag.PersistentNode))
                        Visit(erased_node); //Only Erase non persistent node
                }
            }

            Nodes.TrimExcess();

            //Create All SourceTextBuffer Content associated to Nodes
            CreateNodeSourceTextBufferContents();

            // Comment specific parts (Formalized Comments)
            CommentSpecificParts(node);

            //Now Complete Function Declaration Lines relocation.
            CompleteFunctionDeclarationLinesRelocation();

            //Now deal with Factory Generated Nodes
            if (NeedProcessFactoryGeneratedNodeAttachment)
            {
                CurrentPhase = Phase.FactoryGeneratedNodeAttachment;
                Visit(node);
            }
        }

        /// <summary>
        /// Visit a node.
        /// </summary>
        /// <param name="node">The node to visit</param>
        public void Visit(Node node)
        {
            if (node == null)
                return;
            bool doVisitChildren = false;
            switch (CurrentPhase)
            {
                case Phase.Linearization:
                    //If this node is removed then it has already been handled by the RemovedNode Phase
                    doVisitChildren = ProcessLinearization(node);
                    break;
                case Phase.RemovedNodes:
                    if (node.Comment.HasValue ? node.Comment.Value : false)
                    {//This node is also commented ==> Thus it has already been treated by linearization phase.
                    }
                    else
                    {
                        //Same treatment like Linearization phase.
                        ProcessLinearization(node);
                    }
                    if (node.NodeIndex >= 0)
                    {
                        if (Nodes[node.NodeIndex].node == node)
                        {   //Be sure this the node at the given index, because some remove nodes have not been visited
                            //and thus have their node index set to zero.
                            //So mark this node as removed.
                            Nodes[node.NodeIndex].Removed = true;
                        }
                    }
                    //Remove node phase don't visit Children
                    doVisitChildren = false;
                    break;
                case Phase.FunctionDeclaration:
                    doVisitChildren = ProcessFunctionDeclaration(node);
                    break;
                case Phase.FactoryGeneratedNodeAttachment:
                    doVisitChildren = ProcessFactoryGeneratedNodeAttachment(node);
                    break;
            }

            if (CurrentPhase == Phase.FactoryGeneratedNodeAttachment)
            {//Only Usefull during this phase
                if (node.NodeIndex >= 0 && Nodes[node.NodeIndex].Positions != null)
                {
                    int lastLine = 0;
                    Node lastNode = null;
                    GetAfterLinearizationLastLine(node, ref lastLine, ref lastNode);
                    Nodes[node.NodeIndex].LastLocatedLine = lastLine;
                    Nodes[node.NodeIndex].LastNode = lastNode;
                }
            }
            if (doVisitChildren) 
                foreach (var child in node.Children) 
                    child.Accept(this);
        }

        /// <summary>
        /// Given a node this methods gives its first parent which has a position.
        /// </summary>
        /// <param name="node">The Node to get the first parent which has a position</param>
        /// <returns>The first parent with a position if any, null otherwise</returns>
        private Node GetFirstParentWithPosition(Node node)
        {
            if (node == null)
                return null;
            Node parent = node.Parent;
            while (parent != null)
            {
                //Positions must not be null.
                if (parent.NodeIndex >= 0 && Nodes[parent.NodeIndex].Positions != null)
                    return parent;
                parent = parent.Parent;
            }
            return null;
        }

        /// <summary>
        /// Get the last line of a node.
        /// BECAREFUL this method must be called after the linearization phase,
        /// because it uses positions calculated during the linearization phase.
        /// </summary>
        /// <param name="node">The node to get the last line</param>
        /// <param name="lastLine">output le last line number</param>
        /// <param name="lastNode">The last node of the last line number</param>
        /// <returns></returns>
        internal void GetAfterLinearizationLastLine(Node node, ref int lastLine, ref Node lastNode)
        {
            if (node == null)
                return;
            if (node.NodeIndex >= 0)
            {
                if (Nodes[node.NodeIndex].Positions != null)
                {
                    lastLine = Nodes[node.NodeIndex].Positions.LineNumbers[^1];
                    lastNode = node;
                }
            }
            foreach (var child in node.Children)
            {
                if (child.NodeIndex >= 0 && Nodes[child.NodeIndex].Positions != null)
                {
                    if (Nodes[child.NodeIndex] is NodeFunctionData)
                        continue;//Ignore Function Nodes that will be moved.
                    if (Nodes[child.NodeIndex].node is TypeCobol.Compiler.CodeModel.NestedProgram)
                        return;//After a Nested Program there is nothing else than a Nested Program.
                }
                GetAfterLinearizationLastLine(child, ref lastLine, ref lastNode);
            }
        }

        /// <summary>
        /// Check if the Two given list have an Intersection
        /// </summary>
        /// <param name="l1">The first list</param>
        /// <param name="l2">The second list</param>
        /// <returns>True if there is an intersection, false otherwise</returns>
        public static bool HasIntersection<A>(List<A> l1, List<A> l2)
        {
            if (l1 == l2)
                return true;
            if (l1 == null || l2 == null)
                return false;
            if (l1.Count == 0 || l2.Count == 0)
                return false;
            List<A> tmp;
            if (l1.Count > l2.Count)
            {
                tmp = l2;
                l2 = l1;
                l1 = tmp;
            }
            for (int i = 0; i < l1.Count; i++)
            {
                if (l2.Contains(l1[i]))
                    return true;
            }
            return false;
        }

        /// <summary>
        /// Return a Tuple of the two tokens specified by the TokenTypes in parameters if any
        /// </summary>
        public IEnumerable<Tuple<Token, Token>> GetEnclosingTokensIfAny(Node node, TokenType startTokenType, TokenType stopTokenType)
        {
            var startToken =
                node.CodeElement?.ConsumedTokens.Where(t => t.TokenType == startTokenType).ToArray();
            var stopToken =
                node.CodeElement?.ConsumedTokens.Where(t => t.TokenType == stopTokenType).ToArray();
            if (startToken != null && startToken.Any() &&
                stopToken != null && stopToken.Any())
            {
                // Iterate on the smallest count of token in case of count inequality
                for (int i = 0; i < (startToken.Count() < stopToken.Count() ? startToken.Count() : stopToken.Count()); i++)
                {
                    yield return new Tuple<Token, Token>(startToken[i], stopToken[i]);
                }
            }
        }

        /// <summary>
        /// Comment a node buffer between two specified tokens
        /// </summary>
        public void CommentBetweenTokens(Node node, TokenType startTokenType, TokenType stopTokenType)
        {
            // get the NodeData to have the Buffer
            NodeData nodeData = Nodes.FirstOrDefault(n => n.node == node);
            if (nodeData != null)
            {
                // get the array delimiter consumed Tokens
                var delimiterTokens = GetEnclosingTokensIfAny(node, startTokenType, stopTokenType)?.ToArray();
                if (delimiterTokens != null && delimiterTokens.Any())
                {

                    // Split the Buffer to get an array of string representing the lines
                    string content = new string(nodeData.Buffer.ToArray());
                    string[] lines = content.Split(
                        new[] { "\r\n", "\r", "\n" },
                        StringSplitOptions.None
                    );
                    int[,] bufferLines = nodeData.Buffer.ComputeLinePositions(0, nodeData.Buffer.Size); 
                    var positionList = nodeData.Buffer.GetPositionList();
                    lines = lines.Take(bufferLines.Length).ToArray();
                    foreach (var delimiterToken in delimiterTokens)
                    {

                        // for each lines, if it is inside the formalized comment then comment them (replace the 7th character by a '*') 
                        for (int i = 0; i < bufferLines.GetLength(0) - 1; i++)
                        {
                            if (nodeData.Positions.LineNumbers[i] >= delimiterToken.Item1.Line &&
                                nodeData.Positions.LineNumbers[i] <= delimiterToken.Item2.Line &&
                                bufferLines[i, 1] >= 7) // Avoid comment blank lines
                            {
                                if (positionList.Any() && positionList[0].Pos == bufferLines[i, 0] + 6)
                                {
                                    positionList[0].SetFlag(Position.Flags.InclStart);
                                }
                                nodeData.Buffer.Insert("*", bufferLines[i,0]+6, bufferLines[i,0] + 7);
                            }
                        }
                    }
                }
            }
        }

        public void CommentSpecificParts(Node node)
        {
            // Formalised Comments of Programs (Formalized Comments of Typedef and Functions is already commented)
            if (node is Compiler.Nodes.ProcedureDivision && node.Parent is Compiler.CodeModel.Program)
            {
                CommentBetweenTokens(node, TokenType.FORMALIZED_COMMENTS_START, TokenType.FORMALIZED_COMMENTS_STOP);
            }

            // Multilines Comments
            CommentBetweenTokens(node, TokenType.MULTILINES_COMMENTS_START, TokenType.MULTILINES_COMMENTS_STOP);

            foreach (var child in node.Children)
            {
                CommentSpecificParts(child);
            }
        }

        /// <summary>
        /// Dump All Structures.
        /// </summary>
        public void Dump()
        {
            //Dump Lines Information:
            System.Console.WriteLine("//<<<<<<<<<<<<<<<<<<<<<");
            System.Console.WriteLine("//<<<<<< LINES >>>>>>>");
            System.Console.WriteLine("//>>>>>>>>>>>>>>>>>>>>>");
            StringSourceText buffer = null;
            for (int i = 0; i < LineData.Length; i++)
            {
                if (LineData[i].Buffer != null && buffer != LineData[i].Buffer)
                {
                    buffer = LineData[i].Buffer;
                    System.Console.WriteLine("\\\\\\\\\\\\[StartBuffer]///////////");
                    buffer.Write(System.Console.Out);
                    System.Console.WriteLine("\\\\\\\\\\\\[EndBuffer]///////////");
                }
                if (LineData[i].Buffer == null)
                {
                    System.Console.WriteLine("!!!!!!!!!!![Start NULL Buffer]!!!!!!!!!!!");
                    System.Console.WriteLine("!!!!!!!!!!![End NULL Buffer]!!!!!!!!!!!");
                }
                StringBuilder nodes = new StringBuilder();
                if (LineData[i].LineNodes != null)
                {
                    foreach (int index in LineData[i].LineNodes)
                    {
                        nodes.Append(index);
                        nodes.Append(",");
                    }
                }
                System.Console.WriteLine("Line {0} : Commented = {1}, Nodes[{2}]", i + 1, CommentedLines[i],  nodes.ToString());
            }

            //Dump Lines Information:
            System.Console.WriteLine("//<<<<<<<<<<<<<<<<<<<<<");
            System.Console.WriteLine("//<<<<<< NODES >>>>>>>");
            System.Console.WriteLine("//>>>>>>>>>>>>>>>>>>>>>");
            for (int i = 0; i < Nodes.Count; i++)
            {
                NodeData data = Nodes[i];
                StringBuilder lines = new StringBuilder();
                if (data.Positions != null)
                {
                    foreach (int n in data.Positions.LineNumbers)
                    {
                        lines.Append(n);
                        lines.Append(",");
                    }
                }
                int from = data.Positions != null ? data.Positions.From : -1;
                int to = data.Positions != null ? data.Positions.To : -1;
                int span = data.Positions != null ? data.Positions.Span : -1;
                System.Console.WriteLine("Node {0}<{6}> {7}: Index={1}, Positions[from={2}, To={3}, Span={4}, Lines={5} {8}]", i,
                    i, from, to, span, lines.ToString(), data.node.GetType().FullName, data.Removed ? "?REMOVED?" : "",
                    data.node.Comment != null ? (data.node.Comment.Value ? "COMMENTED" : "") : "");
            }
        }
        /// <summary>
        /// Dump All Structures In the Debugger Output.
        /// </summary>
        public void DebugDump()
        {
            //Dump Lines Information:
            Debug.WriteLine("//<<<<<<<<<<<<<<<<<<<<<");
            Debug.WriteLine("//<<<<<< LINES >>>>>>>");
            Debug.WriteLine("//>>>>>>>>>>>>>>>>>>>>>");
            StringSourceText buffer = null;
            for (int i = 0; i < LineData.Length; i++)
            {
                if (LineData[i].Buffer != null && buffer != LineData[i].Buffer)
                {
                    buffer = LineData[i].Buffer;
                    Debug.WriteLine("\\\\\\\\\\\\[StartBuffer]///////////");
                    Debug.Write(buffer.GetTextAt(0, buffer.Size));                    
                    Debug.WriteLine("\\\\\\\\\\\\[EndBuffer]///////////");
                }
                if (LineData[i].Buffer == null)
                {
                    Debug.WriteLine("!!!!!!!!!!![Start NULL Buffer]!!!!!!!!!!!");
                    Debug.WriteLine("!!!!!!!!!!![End NULL Buffer]!!!!!!!!!!!");
                }
                StringBuilder nodes = new StringBuilder();
                if (LineData[i].LineNodes != null)
                {
                    foreach (int index in LineData[i].LineNodes)
                    {
                        nodes.Append(index);
                        nodes.Append(",");
                    }
                }
                Debug.WriteLine("Line {0} : Commented = {1}, Nodes[{2}]", i + 1, CommentedLines[i], nodes.ToString());
            }

            //Dump Lines Information:
            Debug.WriteLine("//<<<<<<<<<<<<<<<<<<<<<");
            Debug.WriteLine("//<<<<<< NODES >>>>>>>");
            Debug.WriteLine("//>>>>>>>>>>>>>>>>>>>>>");
            for (int i = 0; i < Nodes.Count; i++)
            {
                NodeData data = Nodes[i];
                StringBuilder lines = new StringBuilder();
                if (data.Positions != null)
                {
                    foreach (int n in data.Positions.LineNumbers)
                    {
                        lines.Append(n);
                        lines.Append(",");
                    }
                }
                int from = data.Positions != null ? data.Positions.From : -1;
                int to = data.Positions != null ? data.Positions.To : -1;
                int span = data.Positions != null ? data.Positions.Span : -1;
                Debug.WriteLine("Node {0}<{6}> {7}: Index={1}, Positions[from={2}, To={3}, Span={4}, Lines={5} {8}]", i,
                    i, from, to, span, lines.ToString(), data.node.GetType().FullName, data.Removed ? "?REMOVED?" : "",
                    data.node.Comment != null ? (data.node.Comment.Value ? "COMMENTED" : "") : "");
            }
        }
    }
}