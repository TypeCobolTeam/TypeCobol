using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Text;
using TypeCobol.Codegen.Nodes;
using TypeCobol.Compiler.Nodes;
using TypeCobol.Compiler.Source;
using TypeCobol.Compiler.Text;


namespace TypeCobol.Codegen.Generators
{
    /// <summary>
    /// This class create a mapping between Nodes and their target positions in the source code
    /// for code generation. It built a linear data structure that map each line from the source
    /// document to its corresponding nodes. The Linear structure is built in O(n) where n
    /// is the number of Nodes in the Abstract Tree Nodes.
    /// Each Node is then given an Index in to an Array Of Nodes which is constructed during a
    /// traverse of the Abstract Tree Nodes.
    /// Generating the code using this structure can be performed in the worst case in O(m*n) 
    /// where m is the number of line in the document and n the number of Nodes.
    /// In the best case if we consider that One node is associated to a line, the code generation will
    /// perform in O(m).
    /// </summary>
    public class LinearNodeSourceCodeMapper : NodeVisitor
    {
        /// <summary>
        /// Visitor Phase
        /// </summary>
        public enum Phase
        {
            /// <summary>
            /// The Linearization Phase.
            /// </summary>
            Linearization,
            /// <summary>
            /// The Phase to deal with removed Nodes
            /// </summary>
            RemovedNodes,
            /// <summary>
            /// The Phase to deal with Function Declaration
            /// </summary>
            FunctionDeclaration,
            /// <summary>
            /// The Phase to attach Nodes Generated by a Factory, to the first parent 
            /// having a position.
            /// </summary>
            FactoryGeneratedNodeAttachment,
        }

        /// <summary>
        /// Will we need a ProcessFactoryGeneratedNodeAttachment Phase ?
        /// </summary>
        private bool NeedProcessFactoryGeneratedNodeAttachment;

        /// <summary>
        /// Inteernal position 0
        /// </summary>
        private static Position Pos0 = new Position(0);

        /// <summary>
        /// The Bit Array of line that must be commented
        /// </summary>
        public BitArray CommentedLines
        {
            get;
            internal set;
        }

        /// <summary>
        /// The Bit Array of line that are associated to a node
        /// </summary>
        public BitArray NodedLines
        {
            get;
            internal set;
        }

        /// <summary>
        /// Line Informations
        /// </summary>
        public struct LineInfo
        {
            /// <summary>
            /// The List which give for each line the associated Node Index.
            /// </summary>
            public List<int> LineNodes;
            /// <summary>
            /// The Buffer associated to this line.
            /// </summary>
            public StringSourceText Buffer;
            /// <summary>
            /// The Buffer associated to this line when it is generated in a function body.
            /// </summary>
            public StringSourceText FunctionBodyBuffer;
        }
        /// <summary>
        /// The Map which give for each line the associated Node.
        /// </summary>
        public LineInfo[] LineData;

        /// <summary>
        /// The Generator;
        /// </summary>
        public Generator Generator
        {
            get;
            internal set;
        }

        /// <summary>
        /// The Count of Nodes.
        /// </summary>
        public int NodeCount
        {
            get;
            internal set;
        }

        /// <summary>
        /// The Map which gives for a buffer its associated first line number.
        /// </summary>
        public Dictionary<StringSourceText, int> BufferLineMap
        {
            get;
            private set;
        }
        /// <summary>
        /// Set the current phase
        /// </summary>
        public Phase CurrentPhase
        {
            get;
            internal set;
        }

        /// <summary>
        /// The Current Function Declaration Node.
        /// </summary>
        private Node CurrentFunctionDeclNode
        {
            get;
            set;
        }

        /// <summary>
        /// A Linear Generated Dummy Node
        /// </summary>
        internal class LinearGeneratedNode : Compiler.Nodes.Node
        {
            /// <summary>
            /// Empty constructor.
            /// </summary>
            public LinearGeneratedNode() : base(null)
            {
            }

            /// <summary>
            /// Precalculated positions
            /// </summary>
            public Tuple<int, int, int, List<int>, List<int>> Positions
            {
                get;
                set;
            }

            public override bool VisitNode(TypeCobol.Compiler.CodeElements.IASTVisitor astVisitor)
            {
                return false;
            }
        }

        /// <summary>
        /// Structure that holds Data associated to Nodes
        /// </summary>
        public class NodeData
        {
            /// <summary>
            /// The corresponding Node.
            /// </summary>
            public Node node;
            /// <summary>
            /// Is This node removed?
            /// </summary>
            public bool Removed;
            /// <summary>
            /// If This node is in a function Body, this the Node of the target Function.
            /// </summary>
            public Node FunctionBodyNode;
            /// <summary>
            /// The Last located line of this  node.
            /// </summary>
            public int LastLocatedLine;
            /// <summary>
            /// The Node corresponding to the LastLocatedLine
            /// </summary>
            public Node LastNode;
            /// <summary>
            /// Node's Position
            /// Item1 = From
            /// Item2 = to
            /// Item3 = span on the last line
            /// Item4 = Node's Target Line Numbers.
            /// Item5 = Node's Target Line offsets.
            /// </summary>
            public Tuple<int, int, int, List<int>, List<int>> Positions;
            /// <summary>
            /// The Buffer where this Node is Generated.
            /// </summary>
            public StringSourceText Buffer;
            /// <summary>
            /// From Position in the Source Text Buffer
            /// </summary>
            public Position From;
            /// <summary>
            /// To Position in the Source Text Buffer
            /// </summary>
            public Position To;
        }

        /// <summary>
        /// Data for a Function Declaration Node
        /// </summary>
        public class NodeFunctionData : NodeData
        {
            /// <summary>
            /// The Buffer where a Function Declaration Node is Generated.
            /// </summary>
            public StringSourceText FunctionDeclBuffer;
            /// <summary>
            /// Node Indices associated to Function Declaration.
            /// </summary>
            public List<int> FunctionDeclNodes;
            /// <summary>
            /// The first 1-Based line index of the function body
            /// </summary>
            public int BodyFistLineIndex;
            /// <summary>
            /// The last 1-Based line index of the function body
            /// </summary>
            public int BodyLastLineIndex;
            /// <summary>
            /// The commented Header of a Function declaration
            /// </summary>
            public StringBuilder CommentedHeader;
            /// <summary>
            /// Constructor
            /// </summary>
            public NodeFunctionData()
            {
                FunctionDeclBuffer = new StringSourceText();
                FunctionDeclNodes = new List<int>();
                CommentedHeader = new StringBuilder();
            }
        }

        /// <summary>
        /// The List Of Node Data indexed by Node.NodeIndex
        /// </summary>
        public List<NodeData> Nodes
        {
            get;
            internal set;
        }

        /// <summary>
        /// The Indices of Function Declaration Nodes.
        /// </summary>
        public List<int> FunctionDeclarationNodeIndices
        {
            get;
            private set;
        }

        /// <summary>
        /// During the linearization Phase this is the last Valid Parent which has a location.
        /// </summary>
        private Node LastLocatedParent
        {
            get;
            set;
        }
        /// <summary>
        /// The 1 based last line of the Last LocatedParent Line.
        /// </summary>
        private int LastLocatedParentLine
        {
            get;
            set;
        }

        /// <summary>
        /// The Constructor
        /// </summary>
        /// <param name="Input">Cobol Text Lines in input</param>
        /// <param name="generator">The Generator</param>
        public LinearNodeSourceCodeMapper(Generator generator)
        {
            NodeCount = 0;//Count of Nodes Treated.
            Generator = generator;
            int count = generator.CompilationResults.TokensLines.Count;
            CommentedLines = new BitArray(count);
            NodedLines = new BitArray(count);
            LineData = new LineInfo[count];
            FunctionDeclarationNodeIndices = new List<int>();
            BufferLineMap = new Dictionary<StringSourceText, int>();
        }

        /// <summary>
        /// Check if at the end the buffer being flushed is generated empty.
        /// A buffer is generated empty if all its target lines are commented
        /// and all nodes in the target lines are commented in block and when the buffer
        /// is Trimmed it is empty.
        /// Such buffer can be ignored.
        /// </summary>
        /// <param name="buffer">The buffer to be tested</param>
        /// <returns>true if the buffer is generated empty</returns>
        internal bool IsGeneratedEmptyBuffer(StringSourceText buffer)
        {
            if (BufferLineMap.ContainsKey(buffer))
            {
                //For each contigüous line having the same buffer
                for (int i = BufferLineMap[buffer]; i < LineData.Length && LineData[i].Buffer == buffer; i++)
                {
                    if (LineData[i].LineNodes == null)
                        return false;
                    //Each Node of the line must be commented
                    foreach (int node_index in LineData[i].LineNodes)
                    {
                        if (Nodes[node_index].node.Comment == null ? false : !Nodes[node_index].node.Comment.Value)
                            return false;
                    }
                }
                if (Generator.Layout == ColumnsLayout.CobolReferenceFormat)
                {//Cobol Format
                    for (int i = 0, j = 0; i < buffer.Size; i++, j++)
                    {
                        char c = buffer[i];
                        if (!Char.IsWhiteSpace(c) && c != '\r' && c != '\n')
                        {
                            if (j >= 6 && j < 73)
                                return false;
                        }
                        if (c == '\n')
                            j = 0;
                    }
                }
                else
                {
                    //Now the buffer content must contains only whitespace, carriage return or line feed characters.
                    for (int i = 0; i < buffer.Size; i++)
                    {
                        char c = buffer[i];
                        if (!Char.IsWhiteSpace(c) && c != '\r' && c != '\n')
                            return false;
                    }
                }                
                return true;
            }
            return false;
        }

        /// <summary>
        /// The Function Declaration Processing Phase. The Purpose of this phase is to associate
        /// to a FunctionDeclaration Node all its nodes that belongs to its body.
        /// It also determines the starting line and the ending line in the source code of the
        /// function body.
        /// <param name="node">The node that belongs to a Function Body</param>
        /// <returns>True if children of the given node must be visited, false otherwise</returns>
        /// </summary>
        private bool ProcessFunctionDeclaration(Node node)
        {
            //Function Node Data
            NodeFunctionData funData = (NodeFunctionData)Nodes[CurrentFunctionDeclNode.NodeIndex];
            //Create a New Data
            NodeData data = null;
            bool bHasCodeElement = node is ParameterEntry ? false : 
                (node.CodeElement == null || node.CodeElement.ConsumedTokens == null) ? false : node.CodeElement.ConsumedTokens.Count > 0;
            if (!bHasCodeElement)
            {
                //No Code Element ==> certainly a Generated node                
                node.NodeIndex = NodeCount++;//Give to this node its Index.    
                data = new NodeData();
                data.node = node;
                Nodes.Add(data);
            }
            else
            {//If The Node has positions then linearize it
                ProcessLinearization(node, true);
                if (node.NodeIndex >= 0)
                {
                    data = Nodes[node.NodeIndex];
                    if (funData.BodyFistLineIndex == 0)
                    {//Remember the first the first line of the function body
                        funData.BodyFistLineIndex = data.Positions.Item4[0];
                    }
                    //Track the last line of the function body.
                    funData.BodyLastLineIndex = data.Positions.Item4[0];
                }
            }
            if (node.NodeIndex >= 0)
            {
                //Associate the Function Node
                data.FunctionBodyNode = CurrentFunctionDeclNode;
                //Add the node to the Function Decl nodes list
                funData.FunctionDeclNodes.Add(node.NodeIndex);
            }
            return true;
        }

        /// <summary>
        /// Determine if it is possible to Insert before the given node.
        /// </summary>
        /// <param name="beforeNode">The node to be checked</param>
        /// <returns>true if it is possible to insert before the node, false otherwise.</returns>
        bool CanInsertBeforeNode(Node beforeNode)
        {
            //Debug.Assert(beforeNode != null);
            if (!(beforeNode != null))
                return false;
            //Debug.Assert(beforeNode.NodeIndex > 0);
            if (!(beforeNode.NodeIndex > 0))
                return false;
            //Debug.Assert(Nodes[beforeNode.NodeIndex].Buffer != null);
            if (!(Nodes[beforeNode.NodeIndex].Buffer != null))
                return false;
            //Debug.Assert(Nodes[beforeNode.NodeIndex].Positions != null);
            if (!(Nodes[beforeNode.NodeIndex].Positions != null))
                return false;
            //Debug.Assert(Nodes[beforeNode.NodeIndex].Positions.Item4.Count > 0);
            if (!(Nodes[beforeNode.NodeIndex].Positions.Item4.Count > 0))
                return false;
            //Debug.Assert(Nodes[beforeNode.NodeIndex].Positions.Item5.Count > 0);
            if (!(Nodes[beforeNode.NodeIndex].Positions.Item5.Count > 0))
                return false;
            //Debug.Assert(Nodes[beforeNode.NodeIndex].From != null);
            if (!(Nodes[beforeNode.NodeIndex].From != null))
                return false;
            //Debug.Assert(Nodes[beforeNode.NodeIndex].To != null);
            if (!(Nodes[beforeNode.NodeIndex].To != null))
                return false;
            return true;
        }
        /// <summary>
        /// Insert a Node bafore an another Node.
        /// </summary>
        /// <param name="theNode"></param>
        /// <param name="beforeNode"></param>
        /// <returns>true if the insertion have been performed, false otherwise</returns>
        private bool InsertNodeBeforeNode(Node theNode, Node beforeNode)
        {
            Debug.Assert(theNode != null);
            if (!(theNode != null))
                return false;
            Debug.Assert(beforeNode != null);
            if (!(beforeNode != null))
                return false;
            Debug.Assert(beforeNode.NodeIndex > 0);
            if (!(beforeNode.NodeIndex > 0))
                return false;
            Debug.Assert(theNode.NodeIndex > 0);
            if (!(theNode.NodeIndex > 0))
                return false;
            Debug.Assert(Nodes[beforeNode.NodeIndex].Buffer != null);
            if (!(Nodes[beforeNode.NodeIndex].Buffer != null))
                return false;
            Debug.Assert(Nodes[beforeNode.NodeIndex].Positions != null);
            if (!(Nodes[beforeNode.NodeIndex].Positions != null))
                return false;
            Debug.Assert(Nodes[beforeNode.NodeIndex].Positions.Item4.Count > 0);
            if (!(Nodes[beforeNode.NodeIndex].Positions.Item4.Count > 0))
                return false;
            Debug.Assert(Nodes[beforeNode.NodeIndex].Positions.Item5.Count > 0);
            if (!(Nodes[beforeNode.NodeIndex].Positions.Item5.Count > 0))
                return false;
            Debug.Assert(Nodes[beforeNode.NodeIndex].From != null);
            if (!(Nodes[beforeNode.NodeIndex].From != null))
                return false;
            Debug.Assert(Nodes[beforeNode.NodeIndex].To != null);
            if (!(Nodes[beforeNode.NodeIndex].To != null))
                return false;

            //Determine the Line number of the before line.
            int before_line = Nodes[beforeNode.NodeIndex].Positions.Item4[0] - 1;
            //Add the node to the same line
            int insertIndex = LineData[before_line].LineNodes.IndexOf(beforeNode.NodeIndex);
            LineData[before_line].LineNodes.Insert(insertIndex, theNode.NodeIndex);
            //The Node is Inserted at the beginning of the before node
            Nodes[theNode.NodeIndex].Buffer = Nodes[beforeNode.NodeIndex].Buffer;
            Nodes[theNode.NodeIndex].From = Nodes[beforeNode.NodeIndex].From;
            Nodes[theNode.NodeIndex].To = Nodes[beforeNode.NodeIndex].From;
            //Give to the Node its new span
            Nodes[theNode.NodeIndex].Positions = new Tuple<int, int, int, List<int>, List<int>>(
                Nodes[beforeNode.NodeIndex].Positions.Item1,
                Nodes[beforeNode.NodeIndex].Positions.Item1,
                Nodes[beforeNode.NodeIndex].Positions.Item1,
                new List<int>() { Nodes[beforeNode.NodeIndex].Positions.Item4[0] },
                new List<int>() { Nodes[beforeNode.NodeIndex].Positions.Item5[0] }
                );
            //We must insert a NewLine

            return true;
        }

        /// <summary>
        /// Insert a Node after an another Node.
        /// </summary>
        /// <param name="theNode"></param>
        /// <param name="afterNode"></param>
        /// <returns>true if the insertion have been performed, false otherwise</returns>
        private bool InsertNodeAfterNode(Node theNode, Node afterNode)
        {
            Debug.Assert(theNode != null);
            if (!(theNode != null))
                return false;
            Debug.Assert(afterNode != null);
            if (!(afterNode != null))
                return false;
            Debug.Assert(afterNode.NodeIndex >= 0);
            if (!(afterNode.NodeIndex >= 0))
                return false;
            Debug.Assert(theNode.NodeIndex > 0);
            if (!(theNode.NodeIndex > 0))
                return false;
            Debug.Assert(Nodes[afterNode.NodeIndex].Buffer != null);
            if (!(Nodes[afterNode.NodeIndex].Buffer != null))
                return false;
            Debug.Assert(Nodes[afterNode.NodeIndex].Positions != null);
            if (!(Nodes[afterNode.NodeIndex].Positions != null))
                return false;
            Debug.Assert(Nodes[afterNode.NodeIndex].Positions.Item4.Count > 0);
            if (!(Nodes[afterNode.NodeIndex].Positions.Item4.Count > 0))
                return false;
            Debug.Assert(Nodes[afterNode.NodeIndex].Positions.Item5.Count > 0);
            if (!(Nodes[afterNode.NodeIndex].Positions.Item5.Count > 0))
                return false;
            Debug.Assert(Nodes[afterNode.NodeIndex].From != null);
            if (!(Nodes[afterNode.NodeIndex].From != null))
                return false;
            Debug.Assert(Nodes[afterNode.NodeIndex].To != null);
            if (!(Nodes[afterNode.NodeIndex].To != null))
                return false;

            //Determine the Line number of the before line.
            int before_line = Nodes[afterNode.NodeIndex].Positions.Item4[0] - 1;
            //Add the node to the same line
            LineData[before_line].LineNodes.Add(theNode.NodeIndex);
            //The Node is Inserted at the beginning of the before node
            Nodes[theNode.NodeIndex].Buffer = Nodes[afterNode.NodeIndex].Buffer;
            Nodes[theNode.NodeIndex].From = Nodes[afterNode.NodeIndex].To;
            Nodes[theNode.NodeIndex].To = Nodes[afterNode.NodeIndex].To;
            //Give to the Node its new span
            Nodes[theNode.NodeIndex].Positions = new Tuple<int, int, int, List<int>, List<int>>(
                Nodes[afterNode.NodeIndex].Positions.Item1,
                Nodes[afterNode.NodeIndex].Positions.Item1,
                Nodes[afterNode.NodeIndex].Positions.Item2,
                new List<int>() { Nodes[afterNode.NodeIndex].Positions.Item4[0] },
                new List<int>() { Nodes[afterNode.NodeIndex].Positions.Item5[0] }
                );
            //First generate a new line befor this node
            theNode.SetFlag(Node.Flag.FactoryGeneratedNodeWithFirstNewLine, true);
            return true;
        }

        /// <summary>
        /// This Phase deals with node created by the Generator Factory thus nodes
        /// that cannot be associated to a Position. The strategy is to associate these nodes
        /// to the last line of the first parent node which has positions.
        /// </summary>
        /// <param name="node">The node</param>
        /// <returns>true</returns>
        private bool ProcessFactoryGeneratedNodeAttachment(Node node)
        {
            if (node.IsFlagSet(Node.Flag.FactoryGeneratedNode))
            {   //This Node has been generated by a factory
                //Humm .. attach it to the last valid parent
                //No Code Element ==> certainly a Generated node                
                node.NodeIndex = NodeCount++;//Give to this node its Index.    
                NodeData data_node = new NodeData();
                data_node.node = node;
                Nodes.Add(data_node);
                Node parent = GetFirstParentWithPosition(node);                   
                if (node.IsFlagSet(Node.Flag.FactoryGeneratedNodeKeepInsertionIndex))
                {//So we must keep the insertion index                    
                    Node beforeNode = null;
                    int index = node.Parent.IndexOf(node);
                    while (index != 0 && index != (node.Parent.Children.Count - 1))
                    {
                        beforeNode = node.Parent.Children[index++];
                        //Ignore Functions Declarations.
                        if(!(beforeNode is TypeCobol.Compiler.Nodes.FunctionDeclaration) && beforeNode != node)
                            break;
                    }
                    if (index != 0 && index != (node.Parent.Children.Count - 1))
                    {
                        if (InsertNodeBeforeNode(node, beforeNode))
                            return true;
                    }
                    if (index != 0 && index == (node.Parent.Children.Count - 1) && beforeNode != null)
                    {//Check if we can insert before this last node
                        if(CanInsertBeforeNode(beforeNode))
                        {
                            if (InsertNodeBeforeNode(node, beforeNode))
                            {
                                node.SetFlag(Node.Flag.FullyGenerateRecursivelyFactoryGeneratedNode, true, true);
                                return false;
                            }                                
                        }
                    }
                    if (node.Parent.Children.Count > 1 && index == (node.Parent.Children.Count - 1))
                    {
                    }
                    else
                    {
                        //We must insert after the parent.                        
                        if (node.Parent.IsFlagSet(Node.Flag.FactoryGeneratedNodeKeepInsertionIndex) && node.Children.Count == 0)
                        {
                            //It's parent is already a repositionned node, and this node has no children.
                            node.SetFlag(Node.Flag.FactoryGeneratedNodeKeepInsertionIndex, false);
                            return true;
                        }
                        //Look for the first parent with a position
                        Node valid_parent = node.Parent;
                        if (valid_parent != null && (valid_parent.NodeIndex < 0 || Nodes[valid_parent.NodeIndex].Positions == null))
                            valid_parent = valid_parent.Parent;
                        if (InsertNodeAfterNode(node, valid_parent ?? node.Parent))
                            return true;
                    }
                }           
                //Fall to the default case insert the Node at the last line of the parent node.
                int lastLine = Nodes[parent.NodeIndex].LastLocatedLine;
                Node lastNode = Nodes[parent.NodeIndex].LastNode;
                if (LineData[lastLine - 1].LineNodes == null)
                    LineData[lastLine - 1].LineNodes = new List<int>();
                if ((lastNode is TypeCobol.Compiler.Nodes.End) && lastNode.CodeElement.Type == Compiler.CodeElements.CodeElementType.ProgramEnd)
                    //This a ProgramEnd Node ==> add before the last ProgramEnd node
                    LineData[lastLine - 1].LineNodes.Insert(LineData[lastLine - 1].LineNodes.Count - 1, node.NodeIndex);
                else
                    LineData[lastLine - 1].LineNodes.Add(node.NodeIndex);
            }
            return true;
        }

        /// <summary>
        /// The Linearization Phase.
        /// <param name="node">The node to linearize</param>
        /// <param name="functionBody">true if the node belongs to a function body, false otherwise</param>
        /// <returns>True if children of the given node must be visited, false otherwise</returns>
        /// </summary>
        private bool ProcessLinearization(Node node, bool functionBody = false)
        {
            //During the Linearization Phase, collect data, index of all Nodes.
            //1) Get the Positions of the Node: 
            //  Tuple(from,to,span, lineNumbers, lineOffsets);
            Tuple<int, int, int, List<int>, List<int>> positions = this.Generator.FromToPositions(node);
            if (positions == null)
            { //Node without positions probably a generated node.
                node.NodeIndex = -1;
                if (node.IsFlagSet(Node.Flag.FactoryGeneratedNode))
                {   //This is a Node Generated by The Skeleton Factory Process
                    //=>Indicate that we will need a FactoryGeneratedNodeAttachment Phase
                    NeedProcessFactoryGeneratedNodeAttachment = true;
                }
                return true;
            }
            if (positions.Item4.Count == 0)
            {//This must be a Node in an imported COPY it has no lines associated to it
                node.NodeIndex = -1;
                return true;
            }
            if (positions.Item1 > positions.Item2)
            {   //This is a very strange node that I encountered with position (from > to)
                //I encountered this situation with tests files like:
                //CCC1B045.PGM, CCTF0011.PGM, CCTZ015B, CCTZ0300B, etc..
                //With a DataDescription Node.
                //I Ignore this kind of Node, it is a work around because it seems that
                //such nodes are considered as end of file marking nodes without any code
                //attached to.
                return true;
            }
            bool isFunctionDecl = node is FunctionDeclaration;//Detect Function Declaration
            //If function Node data is instanceof NodeFunctionData class otherwise NodeData class
            NodeData data = isFunctionDecl ? new NodeFunctionData() : new NodeData();
            data.node = node;//Indicate the related Node 
            data.Positions = positions; //Store Node's Positions.          
            node.NodeIndex = NodeCount++;//Give to this node its Index.            

            //Is This Node marked as to be commented ?
            bool bCommented = node.Comment.HasValue ? node.Comment.Value : false;
            StringSourceText buffer = null;
            //The first line number of the target buffer
            int lineindex_buffer = -1;
            foreach (int i in data.Positions.Item4)
            {//For each line concerned by the Node
                int lineIndex = i - 1;//Zero based Index Line Number
                NodedLines[lineIndex] = true;//Now this line is associated to at leat one node.

                //This line is commented;
                if (bCommented)
                {//This node must be commented ==> Mark all its lines that must be commented.
                    CommentedLines[lineIndex] = true;
                }
                //Associate the node to it's line --> Add the Node to list of associated node for the line.
                if (LineData[lineIndex].LineNodes == null)
                {
                    LineData[lineIndex].LineNodes = new List<int>();
                }
                LineData[lineIndex].LineNodes.Add(node.NodeIndex);
                //Associated all Lines to the Buffer of the First line in the list
                if (buffer == null)
                {   //No Buffer allocated yet -> Allocate a new one if current line does not already has one.
                    buffer = functionBody ? LineData[lineIndex].FunctionBodyBuffer : LineData[lineIndex].Buffer;
                    if (buffer == null)
                    {
                        buffer = new StringSourceText();
                        BufferLineMap[buffer] = lineIndex;
                    }
                    lineindex_buffer = BufferLineMap[buffer];
                }
                //Associate its buffer to the current line depending if the current Node is A FunctionDeclaration
                if (functionBody)
                    LineData[lineIndex].FunctionBodyBuffer = buffer;
                else
                    LineData[lineIndex].Buffer = buffer;
                //Propagate Comment from buffer line index to current line.
                //That is to say mark all line concerned by a Commnented Node as commented.
                if (bCommented)
                {
                    for (int k = lineindex_buffer; k < lineIndex; k++)
                        CommentedLines[k] = true;
                }
            }
            //Associate this node to its buffer
            data.Buffer = buffer;
            //Update the positions by translating the position to the real position in the source document.
            //The source document is the document which contais the Full original source code
            int line_from = data.Positions.Item1 - 1;
            int line_to = data.Positions.Item2;
            int span = data.Positions.Item3;
            List<int> lines = data.Positions.Item4;
            List<int> line_offsets = data.Positions.Item5;
            SourceDocument.SourceLine lineindex_srcline = Generator.TargetDocument[lineindex_buffer];            
            SourceDocument.SourceLine line = Generator.TargetDocument[lines[0] - 1];
            int delta = line.From - lineindex_srcline.From;
            data.Positions = new Tuple<int, int, int, List<int>, List<int>>(delta + line_from, delta + line_to, span, lines, line_offsets);
            //Add Node's data to the list of all Node Data
            Nodes.Add(data);
            //------------------------------------------------------------------------------
            // Special case for a Function Declaration Node
            // Swith temporarly to the FunctionDeclaration
            // Phase and visit each child node of the Function's body node.
            //-------------------------------------------------------------------------------
            if (isFunctionDecl && CurrentPhase == Phase.Linearization)
            {
                //Save the Current Phase
                Phase savePhase = CurrentPhase;
                //Switch to Function Declaration Phase
                CurrentPhase = Phase.FunctionDeclaration;
                //The Current Function Node
                CurrentFunctionDeclNode = node;
                //Add to the List of encountered function declaration the Function Declaration Node's Index
                FunctionDeclarationNodeIndices.Add(node.NodeIndex);
                //Visit Each Function body Node.
                foreach (Node body_node in node.Children)
                {
                    Visit(body_node);
                }                
                //Restore the phase
                CurrentPhase = savePhase;
                return false;//Don't deal with its Children
            }
            return true;
        }

        /// <summary>
        /// Collect all lines that have not been associated to a Node during Function Declaration
        /// processing phase. The lines are then associated to Dummy nodes, that have a buffer containing
        /// the source code of the line.
        /// </summary>
        /// <param name="funData">The Function Declaration Data</param>
        private void CollectFunctionBodyUnNodedLines(NodeFunctionData funData)
        {            
            //Compute valid relocation insertion points
            Tuple<int[], int[]> insertLines = ComputeFunctionBodyInsertionLines(funData);
            var Input = Generator.CompilationResults.TokensLines;
            int offset = 0;
            for (int i = funData.BodyFistLineIndex + 1; i < funData.BodyLastLineIndex; i++)
            {//For each line number in the function declaration body                
                if (LineData[i - 1].LineNodes == null)
                {//No Nodes associated to the line.                    
                    //Search valid insertion point
                    int j = Array.BinarySearch(insertLines.Item1, i);
                    if (j < 0)
                        continue;///??? -- No Valid insertion point --> hum... this not a well formed function declaration
                    int insert_index = insertLines.Item2[j];                    
                    if (insert_index < 0)
                    {   //This position correspond to a line with no nodes associated to it
                        insertLines.Item2[j] = -insert_index;                        
                    }
                    //The insert index in the list of nodes
                    insert_index = insertLines.Item2[j] + offset;
                    //Create a specific Node
                    LinearGeneratedNode dummy_node = new LinearGeneratedNode();
                    //Mark it as a specific
                    dummy_node.SetFlag(Node.Flag.ExtraGeneratedLinearNode, true);
                    //Give to the node its index
                    dummy_node.NodeIndex = NodeCount++;
                    //Create Node data for it
                    NodeData data = new NodeData();
                    //Set the target Node
                    data.node = dummy_node;
                    //Give it invalid (Fromn to) positions
                    //--> the text of the line will be added at the end of the generated buffer
                    data.From = Pos0;
                    data.To = Pos0;
                    //Set the associated Function Declaration Node
                    data.FunctionBodyNode = funData.node;
                    //Create the source code buffer in which the text of the line will be stored
                    data.Buffer = new StringSourceText();
                    //Read the line of the text in the buffer
                    TypeCobol.Compiler.Scanner.ITokensLine line = Input[i - 1];
                    data.Buffer.Insert(line.Text, data.Buffer.Size, data.Buffer.Size);
                    data.Buffer.Insert(Environment.NewLine, data.Buffer.Size, data.Buffer.Size);
                    //Add the Global Node list this new Node
                    Nodes.Add(data);
                    //Set for the list its new associated node
                    LineData[i - 1].LineNodes = new List<int>();
                    LineData[i - 1].LineNodes.Add(dummy_node.NodeIndex);
                    //Set associated source text buffer of the line
                    LineData[i - 1].FunctionBodyBuffer = LineData[i - 1].Buffer = data.Buffer;
                    //Inset the Function nodes list this new node at the right insertion index
                    funData.FunctionDeclNodes.Insert(insert_index, dummy_node.NodeIndex);
                    //Increase insertion offset
                    offset++;
                    //Create valid positions for the new node.
                    int from = 0;//From the beginning of the buffer
                    int to = data.Buffer.Size;//To the end of the buffer
                    int span = 0;
                    List<int> lines = new List<int>(){i};//Line number
                    List<int> offsets = new List<int>(){0};//Line number start at offse 0
                    Tuple<int, int, int, List<int>, List<int>> pos = new Tuple<int, int, int, List<int>, List<int>>(from, to, span, lines, offsets);
                    dummy_node.Positions = pos; 
                }
            }
        }

        /// <summary>
        /// Relocate all Function declaration nodes that don't have positions.
        /// Nodes without positions are relocated in the line having the last valid buffer.
        /// </summary>
        /// <param name="funData">The Function Declaration Data</param>
        private void RelocateFunctionBodyNoPositionNodes(NodeFunctionData funData)
        {
            //The last line of the function declaration
            int lastBufferLineNumber = funData.Positions.Item4.Count > 0 ? funData.Positions.Item4[funData.Positions.Item4.Count - 1] :-1;
            for (int j = 0; j < funData.FunctionDeclNodes.Count; j++)
            {//For each Node in the function declaration body
                NodeData node_data = Nodes[funData.FunctionDeclNodes[j]];
                //Get its positions
                Tuple<int, int, int, List<int>, List<int>> positions = 
                    node_data.node.IsFlagSet(Node.Flag.ExtraGeneratedLinearNode) ?
                    ((LinearGeneratedNode)node_data.node).Positions : this.Generator.FromToPositions(node_data.node);
                if (positions != null && node_data.Buffer != null)
                {//If the Node has positions and it is associated to a buffer
                    //The keep the the first line number having a valid buffer
                    lastBufferLineNumber = positions.Item4[0];
                }
                else if (positions == null && lastBufferLineNumber > 0)
                {   //The node has no positions but we know a valid last line number having a valid buffer
                    //Put this node in the same line then the last know buffer
                    if (LineData[lastBufferLineNumber - 1].LineNodes == null)
                        LineData[lastBufferLineNumber - 1].LineNodes = new List<int>();
                    LineData[lastBufferLineNumber - 1].LineNodes.Add(funData.FunctionDeclNodes[j]);
                    //Mark this node as coming from a NoPosGeneratedNode handling.
                    node_data.node.SetFlag(Node.Flag.NoPosGeneratedNode, true);
                }
                else if (positions == null && lastBufferLineNumber < 0)
                {//The Node has no position and dont have a valid last line number witha buffer
                    //Hum... ==> This not a well-formed function declaration.
                    Debug.Assert(lastBufferLineNumber > 0);
                }
                if (j == funData.FunctionDeclNodes.Count - 1)
                {//Mark End Function declaration Node.
                    node_data.node.SetFlag(Node.Flag.EndFunctionDeclarationNode, true);
                }
            }
        }

        /// <summary>
        /// Compute Insertion lines of a Function declaration Body, that is to say line numbers
        /// that begin an instruction : a node.
        /// </summary>
        /// <param name="funData">The Dunction data</param>
        /// <returns>A Tuple(LineNumbers, Insertion Positions)</returns>
        private Tuple<int[], int[]> ComputeFunctionBodyInsertionLines(NodeFunctionData funData)
        {
            List<int> lineNumbers = new List<int>();//List of line numbers where insertion can be done.
            List<int> insertPoints = new List<int>();//List of Intertion point (index) where a node can be inserted.            
            for (int j = 0; j < funData.FunctionDeclNodes.Count; j++)
            {//For each node in the function declaration body.
                NodeData node_data = Nodes[funData.FunctionDeclNodes[j]];
                Tuple<int, int, int, List<int>, List<int>> positions = this.Generator.FromToPositions(node_data.node);
                if (positions != null)
                {//A Node with positions
                    if (!lineNumbers.Contains(positions.Item4[0]))
                    {
                        //Insert interval to the previous insertion point.
                        if (lineNumbers.Count > 0)
                        {
                            int prevPoint = insertPoints[insertPoints.Count - 1];
                            for (int i = lineNumbers[lineNumbers.Count - 1] + 1; i < positions.Item4[0]; i++)
                            {   //Each line numbers not associated to a node must be associated to the last valid  insertion point.
                                //Such insertion point is added with negative value to distinguish it from a valid insertion point.
                                lineNumbers.Add(i);
                                insertPoints.Add(-(prevPoint + 1));                        
                            }
                        }
                        //Add the line number and its position to valid number and insertion point lists.
                        lineNumbers.Add(positions.Item4[0]);
                        insertPoints.Add(j);                        
                    }
                }
            }
            Tuple<int[], int[]> insertLines = new Tuple<int[], int[]>(lineNumbers.ToArray(), insertPoints.ToArray());
            return insertLines;
        }

        /// <summary>
        /// Create All SourceTextBuffer Content associated to Nodes and Create
        /// Node's positions inside the associated buffer.
        /// 
        /// </summary>
        private void CreateNodeSourceTextBufferContents()
        {
            var Input = Generator.CompilationResults.TokensLines;
            StringWriter sw = new StringWriter();
            for (int i = 0; i < LineData.Length; i++)
            {
                if (LineData[i].Buffer != null)
                {
                    TypeCobol.Compiler.Scanner.ITokensLine line = Input[i];
                    LineData[i].Buffer.Insert(line.Text, LineData[i].Buffer.Size, LineData[i].Buffer.Size);
                    LineData[i].Buffer.Insert(Environment.NewLine, LineData[i].Buffer.Size, LineData[i].Buffer.Size);
                }
                //Deal with Function buffer
                if (LineData[i].FunctionBodyBuffer != null)
                {
                    TypeCobol.Compiler.Scanner.ITokensLine line = Input[i];
                    LineData[i].FunctionBodyBuffer.Insert(line.Text, LineData[i].FunctionBodyBuffer.Size, LineData[i].FunctionBodyBuffer.Size);
                    LineData[i].FunctionBodyBuffer.Insert(Environment.NewLine, LineData[i].FunctionBodyBuffer.Size, LineData[i].FunctionBodyBuffer.Size);
                }
            }
            //Create All Node's positions in the corresponding source text buffer.
            for (int i = 0; i < Nodes.Count; i++)
            {
                if (Nodes[i].Positions != null)
                {//Only for Nodes with positions
                    Position from = new Position(Nodes[i].Positions.Item1);
                    Position to = new Position(Nodes[i].Positions.Item2);
                    Nodes[i].Buffer.AddPosition(from);//from position
                    Nodes[i].Buffer.AddPosition(to);//To Pos
                    Nodes[i].From = from;
                    Nodes[i].To = to;
                }
            }
        }

        /// <summary>
        /// For all Function declarations, this method relocates all lines within the function declaration body
        /// that have not been relocated when the function declaration body has been relocated.
        /// This by Dealing with all lines that are not attached to a node.
        /// And relocates nodes without positions
        /// 
        /// </summary>
        private void CompleteFunctionDeclarationLinesRelocation()
        {
            foreach (int fun_index in FunctionDeclarationNodeIndices)
            {
                NodeFunctionData funData = (NodeFunctionData)Nodes[fun_index];
                CollectFunctionBodyUnNodedLines(funData);
                RelocateFunctionBodyNoPositionNodes(funData);
            }
        }

        /// <summary>
        /// Accept this Node to be visited.
        /// </summary>
        /// <param name="node">The Node to be visited</param>
        public void Accept(Node node)
        {
            Nodes = new List<NodeData>();
            //First Phase Linearization
            CurrentPhase = Phase.Linearization;            
            Visit(node);
            //Second Phase Removed Nodes
            CurrentPhase = Phase.RemovedNodes;
            foreach (Node erased_node in this.Generator.ErasedNodes)
            {
                if (!erased_node.IsFlagSet(Node.Flag.PersistentNode))
                    Visit(erased_node);//Only Erase non persistent node
            }
            Nodes.TrimExcess();

            //Create All SourceTextBuffer Content associated to Nodes
            CreateNodeSourceTextBufferContents();

            //Now Complete Function Declaration Lines relocation.
            CompleteFunctionDeclarationLinesRelocation();

            //Now deal with Factory Generated Nodes
            if (NeedProcessFactoryGeneratedNodeAttachment)
            {
                CurrentPhase = Phase.FactoryGeneratedNodeAttachment;
                Visit(node);
            }
        }

        /// <summary>
        /// Visit a node.
        /// </summary>
        /// <param name="node">The node to visit</param>
        public void Visit(Node node)
        {
            if (node == null)
                return;
            bool doVisitChildren = false;
            switch (CurrentPhase)
            {
                case Phase.Linearization:
                    //If this node is removed then it has already been handled by the RemovedNode Phase
                    doVisitChildren = ProcessLinearization(node);
                    break;
                case Phase.RemovedNodes:
                    if (node.Comment.HasValue ? node.Comment.Value : false)
                    {//This node is also commented ==> Thus it has already been treated by linearization phase.
                    }
                    else
                    {
                        //Same treatment like Linearization phase.
                        ProcessLinearization(node);
                    }
                    if (node.NodeIndex >= 0)
                    {
                        if (Nodes[node.NodeIndex].node == node)
                        {   //Be sure this the node at the given index, because some remove nodes have not been visited
                            //and thus have their node index set to zero.
                            //So mark this node as removed.
                            Nodes[node.NodeIndex].Removed = true;
                        }
                    }
                    //Remove node phase don't visit Children
                    doVisitChildren = false;
                    break;
                case Phase.FunctionDeclaration:
                    doVisitChildren = ProcessFunctionDeclaration(node);
                    break;
                case Phase.FactoryGeneratedNodeAttachment:
                    doVisitChildren = ProcessFactoryGeneratedNodeAttachment(node);
                    break;
            }

            if (CurrentPhase == Phase.FactoryGeneratedNodeAttachment)
            {//Only Usefull during this phase
                if (node.NodeIndex >= 0 && Nodes[node.NodeIndex].Positions != null)
                {
                    int lastLine = 0;
                    Node lastNode = null;
                    GetAfterLinearizationLastLine(node, ref lastLine, ref lastNode);
                    Nodes[node.NodeIndex].LastLocatedLine = lastLine;
                    Nodes[node.NodeIndex].LastNode = lastNode;
                }
            }
            if (doVisitChildren) 
                foreach (var child in node.Children) 
                    child.Accept(this);
        }

        /// <summary>
        /// Given a node this methods gives its first parent which has a position.
        /// </summary>
        /// <param name="node">The Node to get the first parent which has a position</param>
        /// <returns>The first parent with a position if any, null otherwise</returns>
        private Node GetFirstParentWithPosition(Node node)
        {
            if (node == null)
                return null;
            Node parent = node.Parent;
            while (parent != null)
            {
                //The Parent must not be a generated node
                if (parent.NodeIndex >= 0 && Nodes[parent.NodeIndex].Positions != null && !(parent is TypeCobol.Codegen.Nodes.GeneratedNode))
                    return parent;
                parent = parent.Parent;
            }
            return parent;
        }

        /// <summary>
        /// Get the last line of a node.
        /// BECAREFUL this method must be called after the linearization phase,
        /// because it uses positions calculated during the linearization phase.
        /// </summary>
        /// <param name="node">The node to get the last line</param>
        /// <param name="lastLine">output le last line number</param>
        /// <param name="lastNode">The last node of the last line number</param>
        /// <returns></returns>
        private void GetAfterLinearizationLastLine(Node node, ref int lastLine, ref Node lastNode)
        {
            if (node == null)
                return;
            if (node.NodeIndex >= 0)
            {
                if (Nodes[node.NodeIndex].Positions != null)
                {
                    lastLine = Nodes[node.NodeIndex].Positions.Item4[Nodes[node.NodeIndex].Positions.Item4.Count - 1];
                    lastNode = node;
                }
            }
            foreach (var child in node.Children)
            {
                if (child.NodeIndex >= 0 && Nodes[child.NodeIndex].Positions != null)
                {
                    if (Nodes[child.NodeIndex] is NodeFunctionData)
                        continue;//Ignore Function Nodes that will be moved.
                    if (Nodes[child.NodeIndex].node is TypeCobol.Compiler.CodeModel.NestedProgram)
                        return;//After a Nested Program there is nothing else than a Nested Program.
                }
                GetAfterLinearizationLastLine(child, ref lastLine, ref lastNode);
            }
        }

        /// <summary>
        /// Check if the Two given list have an Intersection
        /// </summary>
        /// <param name="l1">The first list</param>
        /// <param name="l2">The second list</param>
        /// <returns>True if there is an intersection, false otherwise</returns>
        public static bool HasIntersection<A>(List<A> l1, List<A> l2)
        {
            if (l1 == l2)
                return true;
            if (l1 == null || l2 == null)
                return false;
            if (l1.Count == 0 || l2.Count == 0)
                return false;
            List<A> tmp;
            if (l1.Count > l2.Count)
            {
                tmp = l2;
                l2 = l1;
                l1 = tmp;
            }
            for (int i = 0; i < l1.Count; i++)
            {
                if (l2.Contains(l1[i]))
                    return true;
            }
            return false;
        }

        /// <summary>
        /// Dump All Structures.
        /// </summary>
        public void Dump()
        {
            //Dump Lines Information:
            System.Console.WriteLine("//<<<<<<<<<<<<<<<<<<<<<");
            System.Console.WriteLine("//<<<<<< LINES >>>>>>>");
            System.Console.WriteLine("//>>>>>>>>>>>>>>>>>>>>>");
            StringSourceText buffer = null;
            for (int i = 0; i < LineData.Length; i++)
            {
                if (LineData[i].Buffer != null && buffer != LineData[i].Buffer)
                {
                    buffer = LineData[i].Buffer;
                    System.Console.WriteLine("\\\\\\\\\\\\[StartBuffer]///////////");
                    buffer.Write(System.Console.Out);
                    System.Console.WriteLine("\\\\\\\\\\\\[EndBuffer]///////////");
                }
                if (LineData[i].Buffer == null)
                {
                    System.Console.WriteLine("!!!!!!!!!!![Start NULL Buffer]!!!!!!!!!!!");
                    System.Console.WriteLine("!!!!!!!!!!![End NULL Buffer]!!!!!!!!!!!");
                }
                StringBuilder nodes = new StringBuilder();
                if (LineData[i].LineNodes != null)
                {
                    foreach (int index in LineData[i].LineNodes)
                    {
                        nodes.Append(index);
                        nodes.Append(",");
                    }
                }
                System.Console.WriteLine("Line {0} : Commented = {1}, Nodes[{2}]", i + 1, CommentedLines[i],  nodes.ToString());
            }

            //Dump Lines Information:
            System.Console.WriteLine("//<<<<<<<<<<<<<<<<<<<<<");
            System.Console.WriteLine("//<<<<<< NODES >>>>>>>");
            System.Console.WriteLine("//>>>>>>>>>>>>>>>>>>>>>");
            for (int i = 0; i < Nodes.Count; i++)
            {
                NodeData data = Nodes[i];
                StringBuilder lines = new StringBuilder();
                if (data.Positions != null)
                {
                    foreach (int n in data.Positions.Item4)
                    {
                        lines.Append(n);
                        lines.Append(",");
                    }
                }
                int from = data.Positions != null ? data.Positions.Item1 : -1;
                int to = data.Positions != null ? data.Positions.Item2 : -1;
                int span = data.Positions != null ? data.Positions.Item3 : -1;
                System.Console.WriteLine("Node {0}<{6}> {7}: Index={1}, Positions[from={2}, To={3}, Span={4}, Lines={5} {8}]", i,
                    i, from, to, span, lines.ToString(), data.node.GetType().FullName, data.Removed ? "?REMOVED?" : "",
                    data.node.Comment != null ? (data.node.Comment.Value ? "COMMENTED" : "") : "");
            }
        }
        /// <summary>
        /// Dump All Structures In the Debugger Output.
        /// </summary>
        public void DebugDump()
        {
            //Dump Lines Information:
            Debug.WriteLine("//<<<<<<<<<<<<<<<<<<<<<");
            Debug.WriteLine("//<<<<<< LINES >>>>>>>");
            Debug.WriteLine("//>>>>>>>>>>>>>>>>>>>>>");
            StringSourceText buffer = null;
            for (int i = 0; i < LineData.Length; i++)
            {
                if (LineData[i].Buffer != null && buffer != LineData[i].Buffer)
                {
                    buffer = LineData[i].Buffer;
                    Debug.WriteLine("\\\\\\\\\\\\[StartBuffer]///////////");
                    Debug.Write(buffer.GetTextAt(0, buffer.Size));                    
                    Debug.WriteLine("\\\\\\\\\\\\[EndBuffer]///////////");
                }
                if (LineData[i].Buffer == null)
                {
                    Debug.WriteLine("!!!!!!!!!!![Start NULL Buffer]!!!!!!!!!!!");
                    Debug.WriteLine("!!!!!!!!!!![End NULL Buffer]!!!!!!!!!!!");
                }
                StringBuilder nodes = new StringBuilder();
                if (LineData[i].LineNodes != null)
                {
                    foreach (int index in LineData[i].LineNodes)
                    {
                        nodes.Append(index);
                        nodes.Append(",");
                    }
                }
                Debug.WriteLine("Line {0} : Commented = {1}, Nodes[{2}]", i + 1, CommentedLines[i], nodes.ToString());
            }

            //Dump Lines Information:
            Debug.WriteLine("//<<<<<<<<<<<<<<<<<<<<<");
            Debug.WriteLine("//<<<<<< NODES >>>>>>>");
            Debug.WriteLine("//>>>>>>>>>>>>>>>>>>>>>");
            for (int i = 0; i < Nodes.Count; i++)
            {
                NodeData data = Nodes[i];
                StringBuilder lines = new StringBuilder();
                if (data.Positions != null)
                {
                    foreach (int n in data.Positions.Item4)
                    {
                        lines.Append(n);
                        lines.Append(",");
                    }
                }
                int from = data.Positions != null ? data.Positions.Item1 : -1;
                int to = data.Positions != null ? data.Positions.Item2 : -1;
                int span = data.Positions != null ? data.Positions.Item3 : -1;
                Debug.WriteLine("Node {0}<{6}> {7}: Index={1}, Positions[from={2}, To={3}, Span={4}, Lines={5} {8}]", i,
                    i, from, to, span, lines.ToString(), data.node.GetType().FullName, data.Removed ? "?REMOVED?" : "",
                    data.node.Comment != null ? (data.node.Comment.Value ? "COMMENTED" : "") : "");
            }
        }
    }
}