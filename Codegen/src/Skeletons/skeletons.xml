<?xml version="1.0" encoding="UTF-8"?>
<skeletons>
  <!-- comment TYPEDEF -->
  <skeleton name="TYPEDEF">
    <conditions>
      <condition node="TypeCobol.Compiler.Nodes.TypeDefinition"/>
    </conditions>
    <patterns>
      <pattern location="NODE" action="comment"></pattern>
    </patterns>
  </skeleton>

  <!-- comment GLOBAL_STORAGE SECTION -->
  <skeleton name="GlobalStorageSection">
    <conditions>
      <condition node="TypeCobol.Compiler.Nodes.GlobalStorageSection"/>
    </conditions>
    <patterns>
      <pattern location="NODE" action="clone"></pattern>
      <pattern location="NODE" action="comment"></pattern>
    </patterns>
  </skeleton>

  <!-- replace TYPE BOOL declarations -->
  <skeleton name="BOOL.DECLARE" var="level,name,value,global">
    <conditions>
      <condition node="TypeCobol.Compiler.Nodes.DataDescription" type="BOOL"/>
    </conditions>
    <patterns>
      <pattern location="NODE" action="replace">
        @{
        var items = "";
        if (@Model.value.Length == 0) {
        items = @Model.level +"  "+@Model.name+"-value PIC X VALUE LOW-VALUE" + @Model.global + ".";
        }
        else {
        items = @Model.level + "  " + @Model.name + "-value PIC X VALUE " +  @Model.value + @Model.global + ".";
        }
        }
@items
    88  @Model.name       VALUE 'T'.
    88  @Model.name-false VALUE 'F'
                    X'00' thru 'S'
                    'U' thru X'FF'.
      </pattern>
    </patterns>
  </skeleton>

  <!-- create redefines for pointers -->
  <skeleton name="POINTER.REDEFINES" var="level,name,hash">
    <conditions>
      <condition node="TypeCobol.Compiler.Nodes.DataDescription" Usage="Pointer" isPointerIncrementation="true"/>
    </conditions>
    <patterns>
      <pattern location="NODE" action="replace">
        @{
        var items = "";
        items = @Model.level   + "  " + @Model.name + " POINTER.\n" +
        @Model.level + " redefines " + @Model.name + ".\n" +
        "    " + (Int32.Parse(@Model.level)+1).ToString("00") + " " +
        (@Model.name.Length.CompareTo(22) != 1 ? @Model.name : @Model.name.Substring(0,22)) + @Model.hash + " pic S9(05) comp-5.";
        }
        @items
      </pattern>
    </patterns>
  </skeleton>

  <!-- delete and replace TYPE -->
  <skeleton name="TYPE">
    <conditions>
      <condition node="TypeCobol.Compiler.Nodes.DataDescription" type="*"/>
    </conditions>
    <patterns>
      <pattern location="NODE" action="expand"></pattern>
    </patterns>
  </skeleton>

  <!-- replace SET <boolean> TO FALSE -->
  <skeleton name="BOOL.SET" var="receiver">
    <conditions>
      <condition node="TypeCobol.Compiler.Nodes.Set" sender.type="BOOL" sender="FALSE"/>
    </conditions>
    <patterns>
      <pattern name = "BOOL.SET" location="NODE" action="replace">
        @{
        var item = "";
        for (int i = 0; i &lt; @Model.receiver.Count;  i++){
        if (i == 0){
        item += "SET " + @Model.receiver[i] + "-false\n";
        }
        else{
        item += "         " + @Model.receiver[i] + "-false\n";
        }

        }
        item = item.Remove(item.Length-1);
        item += " TO TRUE";
        }
        @item
      </pattern>
    </patterns>
  </skeleton>

  <!-- replace SET <pointer> UP BY <integer> -->
  <skeleton name="POINTER.INCREMENT" var="displayableReceivers, sender, incrementDirection, needCompute">
    <conditions>
      <condition node="TypeCobol.Compiler.Nodes.Set" receiverUsage="Pointer"/>
    </conditions>
    <patterns>
      <pattern name="POINTER.INCREMENT" location="NODE" action="replace">
        @{
        var item = "";
        if (@Model.needCompute)
        {
         foreach (var receiver in @Model.displayableReceivers)
         {
           item += "COMPUTE " + receiver + " = " + receiver + (@Model.incrementDirection == "Down" ? " - " : " + ") + @Model.sender.ToString() + ".\n";
         }
        }
        else
        {
         item = @Model.incrementDirection == "Down" ? "SUBTRACT " + @Model.sender.ToString() + " from " : "ADD " + @Model.sender.ToString() + " to ";
         foreach (var receiver in @Model.displayableReceivers)
           item += receiver + ", ";
        }
        item = item.Remove(item.Length - 2);
        }
        @item
      </pattern>
    </patterns>
  </skeleton>

  <!-- delete UNSAFE -->
  <skeleton name="UNSAFE">
    <conditions>
      <condition node="TypeCobol.Compiler.CodeElements.VariableWriter" unsafe="true"/>
    </conditions>
    <patterns>
      <pattern location="NODE" action="erase">UNSAFE</pattern>
    </patterns>
  </skeleton>

  <skeleton name="TCRFUN_LIBRARY_COPY" var="copyname">
    <conditions>
      <condition node="TypeCobol.Compiler.Nodes.LibraryCopy"/>
    </conditions>
    <patterns>
      <pattern location="NODE" action="comment"></pattern>
      <pattern location="program.data-division.linkage" action="create" group="TCRFUN_CODEGEN_LIBRARY_COPY">
        COPY @Model.copyname REPLACING ==:@Model.copyname:== BY ==FCT==.
      </pattern>
      <pattern location="program.data-division.linkage" action="create" group="TCRFUN_CODEGEN_CALL_MODE">
        01  CallData.
        05  DescriptionId PIC X(08).
        88 CallIsCopy VALUE '@Model.copyname'.
      </pattern>
      <!--pattern location="program.begin" action="create" group="TCRFUN_CODEGEN_COPY">
@{
  var items = "";
  foreach (var f in @Model.definitions.functions.Public) {
    items += "*      05 :"+@Model.copyname+":-"+f.Label+"   PROCEDURE-POINTER VALUE NULL.\n";
  }
}
*01  :@Model.copyname:.
*    02                         PIC X(08) VALUE '@Model.copyname'.
*    02                         PIC X(03) VALUE '000'.
*    02 :@Model.copyname:-FunctionPointers.
@items*
*      05 :@Model.copyname:-Reserve   PIC X(361).
      </pattern-->
    </patterns>
  </skeleton>

  <!-- replace DECLARE FUNCTION PUBLIC by a stacked program -->
  <skeleton name="FUN.DECLARE.PUBLIC" var="definitions,copyname,programName8">
    <conditions>
      <condition node="TypeCobol.Compiler.Nodes.FunctionDeclaration" visibility="public" isnested="false"/>
    </conditions>
    <patterns>      
     <pattern location="program.data-division.working-storage" action="create" newline="false" group="TCRFUN_CODEGEN_IS_LOADED">
      </pattern>
      <!-- CALLEE LINKAGE SECTION WITHOUT EXTERNAL -->
      <pattern location="program.data-division.linkage" action="create" newline="false" group="TCRFUN_CODEGEN_POINTER_LINKAGE" deprecated="false">
        @{
        var items = "01 TC-FunctionCode pic X(30).\n";
        foreach (var f in @Model.definitions.functions.Public) {
        items += "* Function which call program " + f.Hash + "\n";
        items += "* Which is generated code for " + f.QualifiedName + "\n";
        items += "    88 Fct-" + f.Hash + "-" + f.ID + "\n";
        items += "       value 'Fct=" + f.Hash + "-" + f.ID + "'.\n";
        }
        items += "\n";
        for(var i=1; i != (@Model.definitions.MaxArgsCount + 1); i++) {
        items += "01 arg" + i + " pic X.\n";
        }
        items = items.Substring(0, items.Length - 1);
        }
        @items
      </pattern>

      <pattern action="expand" location="program.end" newline="false">
      </pattern>

      <!-- CALLEE WORKING-STORAGE SECTION WITHOUT EXTERNAL-->
      <pattern name="ProcedureDivisionCalleeWithoutExternal" location="program.procedure-division.sentence-([0-9]+).begin" action="create" newline="false" group="TCRFUN_CODEGEN_ADAPTABLE_BEHAVIOUR" deprecated="false">
        @{
        var items = "";
        if (@Model.definitions.MaxArgsCount == 0) {
        items += "                 .\n";
        }
        if (@Model.definitions.MaxArgsCount == 1) {
        items += "                 arg1.\n";
        }
        if (@Model.definitions.MaxArgsCount > 1) {
        items += "                 arg1\n";
        for(var i=2; i != @Model.definitions.MaxArgsCount; i++) {
        items += "                   arg" + i + "\n";
        }
        items += "                   arg" + @Model.definitions.MaxArgsCount + ".\n";
        }
        items = items.Substring(0, items.Length - 1);
        }
        @items
    PERFORM INIT-LIBRARY
    PERFORM FctList-Process-Mode
    GOBACK.
        @{
        var entries = "";
        foreach (var f in @Model.definitions.functions.Public) {
        entries += "       when Fct-"+ f.Hash + "-" + f.ID + "\n";
        entries += "          call '" + f.Hash + "'";
        int nbr = f.Profile.Parameters.Count;
        if (nbr == 0) {
        entries += "\n";
        }
        else {
        entries += " using arg1\n";
        if (nbr > 1) {
        for(int i=2; i != (nbr+1); i++) {
        entries += "                                 arg" + i + "\n";
        }
        }
        }
        }
        entries += "       when other\n";
        entries += "          Perform Handle-Error\n";
        entries += "    end-evaluate";
        }
FctList-Process-Mode.
    evaluate true
@entries
    .
Handle-Error.
    continue
      </pattern>

    </patterns>
  </skeleton>
  
  <!-- replace DECLARE FUNCTION PRIVATE by a stacked program -->
  <skeleton name="FUN.DECLARE.PRIVATE" var="definitions">
    <conditions>
      <condition node="TypeCobol.Compiler.Nodes.FunctionDeclaration" visibility="private" />
      <condition node="TypeCobol.Compiler.Nodes.FunctionDeclaration" visibility="local" />
    </conditions>
    <patterns>
      <pattern action="expand" location="program.end"></pattern>
    </patterns>
  </skeleton>

  <!-- replace DECLARE PUBLIC NESTED FUNCTION by a nested program -->
  <skeleton name="FUN.DECLARE.NESTED" var="definitions">
    <conditions>
      <condition node="TypeCobol.Compiler.Nodes.FunctionDeclaration" visibility="public" isnested="true"/>
    </conditions>
    <patterns>
      <pattern action="expand" location="program.end"></pattern>
    </patterns>
  </skeleton>

  <!-- generate code going with the generation of a public nested program in the main program-->
  <skeleton name="MAIN.DECLARE.NESTED" var="definitions,programName8">
    <conditions>
      <condition node="TypeCobol.Compiler.CodeModel.SourceProgram" containnested="true"/>
    </conditions>
    <patterns>
      <pattern location="program.data-division.linkage" action="create" group="TCRFUN_CODEGEN_POINTER_LINKAGE" deprecated="false">
        @{
        var items = "";
        if (@Model.definitions.functionsGeneratedAsNested.Public.Count > 0) {
        items += "01 FunctionCode pic X(30).\n";
        }
        int maxVarCount = 0;
        foreach (var function in @Model.definitions.functionsGeneratedAsNested.Public) {
        if (function.Profile.Parameters.Count > maxVarCount) {
        maxVarCount = function.Profile.Parameters.Count;
        }
        }
        for (int i = 1; i &lt;= maxVarCount; i++) {
        items += "01 arg" + i + " PIC X.\n";
        }
        }
        @items
      </pattern>

      <pattern location="program.procedure-division.end" action="create" group="TCRFUN_CODEGEN_ENTRYPOINT" deprecated="false">
        @{
        var items = "";
        if (@Model.definitions.functionsGeneratedAsNested.Public.Count &gt; 0) {
        items += "PA-ALL-ENTRIES.\n";
        string usingVariables;

        foreach (var functionNode in @Model.definitions.functionsGeneratedAsNested.Public) {

        TypeCobol.Compiler.Nodes.FunctionDeclaration function = (TypeCobol.Compiler.Nodes.FunctionDeclaration) functionNode;
        usingVariables = string.Empty;

        for (int i = 1; i &lt;= function.Profile.Parameters.Count; i++) {
        usingVariables += " TC-A" + i;
        }

        items += "    ENTRY '" + function.Hash + "' USING" + usingVariables + '\n';
        items += "        CALL \"" + function.Hash + "\" USING" + usingVariables + '\n';
        items += "        GOBACK.\n\n";
        }
        }
        }
        @items
      </pattern>
      <pattern location="program.data-division.working-storage" action="create" group="TCRFUN_CODEGEN_IS_LOADED">
        @{
        var items = "";
        if (@Model.definitions.functionsGeneratedAsNested.Public.Count &gt; 0) {
        items += "01  TC-"+ @Model.programName8 + "-FctList-Loaded PIC X(02).\n";
        items += "    88 TC-"+ @Model.programName8 + "-FctList-IsLoaded      VALUE 'OK'.\n";
        }
        }
        @items
      </pattern>

      <!--CALLEE WORKING-STORAGE SECTION WITHOUT EXTERNAL-->
      <pattern location="program.data-division.working-storage" action="create" group="TCRFUN_CODEGEN_POINTER_ARRAY" deprecated="false">
        @{
        var items = "";
        if (@Model.definitions.functionsGeneratedAsNested.Public.Count > 0) {
        items += "01 TC-FunctionCode pic X(30).\n";
        }
        foreach (var f in @Model.definitions.functionsGeneratedAsNested.Concat(@Model.definitions.functions.Public, true)) {
        items += "* Function which call program " + f.Hash + "\n";
        items += "* Which is generated code for " + f.QualifiedName + "\n";
        items += "    08 Fct-" + f.Hash + "-" + f.ID + "\n";
        items += "       value 'Fct=" + f.Hash +"-" + f.ID + "'.\n";
        }
        }
        @items
      </pattern>

      <!--CALLEE WORKING-STORAGE SECTION WITHOUT EXTERNAL-->
      <pattern name="ProcedureDivisionCalleeWithoutExternal" location="program.procedure-division.sentence-([0-9]+).begin" action="create" newline="false" group="TCRFUN_CODEGEN_ADAPTABLE_BEHAVIOUR" deprecated="false">
        @{
        var items = "";
        if (@Model.definitions.MaxArgsCount == 0) {
        items += "                 .\n";
        }
        if (@Model.definitions.MaxArgsCount == 1) {
        items += "                 arg1.\n";
        }
        if (@Model.definitions.MaxArgsCount > 1) {
        items += "                 arg1\n";
        for(var i=2; i != @Model.definitions.MaxArgsCount; i++) {
        items += "                   arg" + i + "\n";
        }
        items += "                   arg" + @Model.definitions.MaxArgsCount + ".\n";
        }
        }
        @items

        @{
        var items = "";
        if (@Model.definitions.functionsGeneratedAsNested.Public.Count > 0) {
        items += "    PERFORM INIT-LIBRARY\n";
        items += "    PERFORM FctList-Process-Mode\n";
        items += "    GOBACK.\n\n";
        items += " FctList-Process-Mode.\n";
        items += "    evaluate true\n";

        foreach (var f in @Model.definitions.functionsGeneratedAsNested.Concat(@Model.definitions.functions.Public, true)) {
        items += "        when Fct-"+ f.Hash + "-" + f.ID + "\n";
        items += "           call '" + f.Hash + "'";
        int nbr = f.Profile.Parameters.Count;
        if (nbr == 0) {
        items += "\n";
        }
        else {
        items += " using arg1\n";
        if (nbr > 1) {
        for(int i=2; i != (nbr+1); i++) {
        items += "                                 arg" + i + "\n";
        }
        }
        }
        @items += "    when other\n";
        @items += "       Perform Handle-Error\n";
        @items += "  end-evaluate\n";
        }
        }
        @items
    .
Handle-Error.
    continue
      </pattern>
    </patterns>
  </skeleton>


  <!-- replace function invocation by a CALL and create utility variables -->
  <skeleton name="FUN.CALL" var=" function  ,receiver ">
    
    <patterns>
      <pattern location="data-division.working-storage" action="create" group="@Model.function.Library-VARS" var="function=$function">
01 TypeCobol-Generated.
        05 @Model.function.Copy COPY @Model.function.Copy.
        05 @Model.function.Library PIC X(08) VALUE '@Model.function.Library'.
      </pattern>
      <pattern location="data-division.working-storage" action="create" group="functions">
01 ERROR-CODE PIC X(08).
      </pattern>
      <!--pattern location="data-division.working-storage" action="create" group="@Model.function.Name" var="type=$function.Result.Definition">
01 @Model.function.Name-RESULT @Model.function.Result.Definition.
      </pattern-->
      <pattern location="procedure-division.begin" action="create" group="@Model.function.Library-CALL">
    IF @Model.function.Copy-POINTER-TABLE = LOW_VALUE
        CALL @Model.function.Library USING @Model.function.Copy
    END-IF
      </pattern>
      <pattern location="NODE" action="replace">
@{
  var funparams = "";
  foreach (var p in @Model.function.InputParameters) {
    funparams += "        BY " + p.SendingMode + " " + p.Value + "\n";
  }
}
    CALL @Model.function.Name USING
@funparams
        BY REFERENCE @Model.function.Name-RESULT
        BY REFERENCE ERROR-CODE

    IF ERROR-CODE = ZERO
        MOVE @Model.function.Name-RESULT TO @Model.receiver
    ELSE
*    TODO: error management
    END-IF
      </pattern>
    </patterns>
  </skeleton>
  
  <!-- replace procedure-style invocation by a standard COBOL CALL -->
  <skeleton name="PROC.STYLE.CALL.TO.COBOL">
    <conditions>
      <condition node="TypeCobol.Compiler.Nodes.ProcedureStyleCall" />
    </conditions>
    <patterns>
      <pattern location="NODE" action="expand"></pattern>
    </patterns>
  </skeleton>
  
  <!-- replace "::" qualification by "OF" inverse qualification -->
  <skeleton name="QUALIFICATION">

    <patterns>
      <pattern action="expand" location="NODE"></pattern>
    </patterns>
  </skeleton>

  <skeleton name="PGM.USE.GLOBALSTORAGE" var="useglobalstoragevariable">
    <conditions>
      <condition node="TypeCobol.Compiler.CodeModel.Program" />
    </conditions>
    <patterns>
      <pattern location="program.data-division.linkage.begin" name="TypeCobol.Codegen.Contribution.GlobalStorage" action="contribute" deprecated="false" boolean_property="useglobalstoragevariable" newline="true"></pattern>
    </patterns>
  </skeleton>
  
  <skeleton name="PROGRAM.IMPORT.FUN.PUBLIC" var="imports, useglobalstoragevariable, sourceprogramhash, cobolvalidname">
    <conditions>
      <condition node="TypeCobol.Compiler.CodeModel.Program"/>
    </conditions>
    <patterns>
      <pattern location="NODE" action="remarks"></pattern> <!-- Remarks Directive -->

      <!-- CALLER WORKING-STORAGE SECTION WITHOUT EXTERNAL-->
      <pattern location="program.data-division.working-storage.begin" action="create" newline="false" boolean_property="imports.IsNotEmpty" deprecated="false">
        @{
        var types = "";
        var items = "01 TypeCobol-Generated.\n";
        foreach (var pgm in @Model.imports.Programs.Values) {
        items += "    05 TC-"+ pgm.Name + " pic X(08) value '" + pgm.Name.ToUpperInvariant() + "'.\n";
        foreach (var proc in pgm.Procedures) {
        var name = pgm.Name + "-Fct-" + proc.Value.Hash + "-" + proc.Value.Name;
        if (name.Length > 30) {
        name = name.Substring(0, 30);
        }
        types += "    05 " + name + " pic X(30)\n";
        name = "Fct=" + proc.Value.Hash + "-" + proc.Value.Name;
        if (name.Length > 30) {
        name = name.Substring(0, 30);
        }
        types += "         value '" + name + "'.\n";
        }
        }
        items += types;
        items = items.Substring(0, items.Length - 1);
        }
        @items
      </pattern>

      <pattern location="program.procedure-division.declaratives-header.end,//program.procedure-division.sentence-([0-9]+).begin,//program.procedure-division.paragraph.sentence-([0-9]+).begin|program.procedure-division.sentence-([0-9]+).begin|program.procedure-division.paragraph.sentence-([0-9]+).begin|program.procedure-division.sentence-0.begin" action="create" boolean_property="useglobalstoragevariable">
        @{
        var clause = "";
        if (!@Model.imports.HasPublicProcedures) {
        clause += "* Get the data from the global storage section\n";
        clause += "    CALL '" + @Model.sourceprogramhash + "' USING\n";
        clause += "        by reference address of TC-GlobalData\n";
        clause += "    end-call\n";
        }
        }
        @clause
      </pattern>

    </patterns>
    </skeleton>
</skeletons>